(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("babel-regenerator-runtime"), require("json-stable-stringify"), require("bs58"), require("fast-sha256"), require("buffer"), require("base64url"), require("tweetnacl"), require("fs"), require("path"), require("base64-js"), require("axios"), require("es6-promise"));
	else if(typeof define === 'function' && define.amd)
		define("token-io.node", ["babel-regenerator-runtime", "json-stable-stringify", "bs58", "fast-sha256", "buffer", "base64url", "tweetnacl", "fs", "path", "base64-js", "axios", "es6-promise"], factory);
	else if(typeof exports === 'object')
		exports["token-io.node"] = factory(require("babel-regenerator-runtime"), require("json-stable-stringify"), require("bs58"), require("fast-sha256"), require("buffer"), require("base64url"), require("tweetnacl"), require("fs"), require("path"), require("base64-js"), require("axios"), require("es6-promise"));
	else
		root["token-io.node"] = factory(root["babel-regenerator-runtime"], root["json-stable-stringify"], root["bs58"], root["fast-sha256"], root["buffer"], root["base64url"], root["tweetnacl"], root["fs"], root["path"], root["base64-js"], root["axios"], root["es6-promise"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_14__, __WEBPACK_EXTERNAL_MODULE_25__, __WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_35__, __WEBPACK_EXTERNAL_MODULE_36__, __WEBPACK_EXTERNAL_MODULE_48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(2);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = require("babel-regenerator-runtime");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Token = __webpack_require__(3);

	var _Token2 = _interopRequireDefault(_Token);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = _Token2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Crypto = __webpack_require__(4);

	var _Crypto2 = _interopRequireDefault(_Crypto);

	var _BrowserCryptoEngine = __webpack_require__(16);

	var _BrowserCryptoEngine2 = _interopRequireDefault(_BrowserCryptoEngine);

	var _MemoryCryptoEngine = __webpack_require__(19);

	var _MemoryCryptoEngine2 = _interopRequireDefault(_MemoryCryptoEngine);

	var _ManualCryptoEngine = __webpack_require__(21);

	var _ManualCryptoEngine2 = _interopRequireDefault(_ManualCryptoEngine);

	var _UnsecuredFileCryptoEngine = __webpack_require__(22);

	var _UnsecuredFileCryptoEngine2 = _interopRequireDefault(_UnsecuredFileCryptoEngine);

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	var _Member = __webpack_require__(27);

	var _Member2 = _interopRequireDefault(_Member);

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	var _HttpClient = __webpack_require__(44);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	var _TokenRequest = __webpack_require__(47);

	var _TokenRequest2 = _interopRequireDefault(_TokenRequest);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Promise polyfill for IE and older browsers
	__webpack_require__(48).polyfill();

	/**
	 * Main entry object. Allows creation of members, provisioning of devices, logging in,
	 * sending notifications, etc, as well as access to other SDK classes.
	 */

	var Token = function () {
	    /**
	     * Construct the Token SDK object, pointing to the given environment.
	     *
	     * @param {string} env - which environment (gateway) to use, (e.g. prd)
	     * @param {string} developerKey - the developer key
	     * @param {string} keyDir - absolute directory name of key storage directory
	     * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
	     * @param {bool} loggingEnabled - enable HTTP error logging if true
	     * call error. For example: SDK version mismatch
	     * @param {string} customSdkUrl - set to override the default sdk url
	     */
	    function Token() {
	        var env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'prd';
	        var developerKey = arguments[1];
	        var keyDir = arguments[2];
	        var globalRpcErrorCallback = arguments[3];
	        var loggingEnabled = arguments[4];
	        var customSdkUrl = arguments[5];

	        _classCallCheck(this, Token);

	        this._env = env;
	        this._globalRpcErrorCallback = globalRpcErrorCallback;
	        this._developerKey = developerKey;
	        this._loggingEnabled = loggingEnabled;
	        this._customSdkUrl = customSdkUrl;
	        this._unauthenticatedClient = new _HttpClient2.default(env, developerKey, this._globalRpcErrorCallback, loggingEnabled, customSdkUrl);

	        /* Available security levels for keys */
	        this.KeyLevel = _config2.default.KeyLevel;

	        /* Crypto utility functions */
	        this.Crypto = _Crypto2.default;

	        /* Other utility functions */
	        this.Util = _Util2.default;

	        /* Class for using the browser crypto engine */
	        this.BrowserCryptoEngine = _BrowserCryptoEngine2.default;

	        /* Class for using the memory crypto engine */
	        this.MemoryCryptoEngine = _MemoryCryptoEngine2.default;

	        /* Class for using the hardcoded crypto engine */
	        this.ManualCryptoEngine = _ManualCryptoEngine2.default;

	        if (keyDir) {
	            _UnsecuredFileCryptoEngine2.default.setDirRoot(keyDir);
	        }
	        /* Class for the Unsecured filestore key root */
	        this.UnsecuredFileCryptoEngine = _UnsecuredFileCryptoEngine2.default;

	        /* Class for constructing TokenRequest objects */
	        this.TokenRequest = _TokenRequest2.default;
	    }

	    /**
	     * If we're on a token page, sets up an iframe to avoid CORS preflights. All requests in this
	     * window will be routed through the iframe.
	     *
	     * @param {string} env - which environment (gateway) to use, (e.g. prd)
	     */


	    _createClass(Token, [{
	        key: "aliasExists",


	        /**
	         * Checks if a given alias already exists
	         *
	         * @param {Object} alias - alias to check
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} result - true if alias exists, false otherwise
	         */
	        value: function aliasExists(alias, realm) {
	            var _this = this;

	            return _Util2.default.callAsync(this.aliasExists, function _callee() {
	                var res;
	                return regeneratorRuntime.async(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                _context.next = 2;
	                                return regeneratorRuntime.awrap(_this._unauthenticatedClient.resolveAlias(alias, realm));

	                            case 2:
	                                res = _context.sent;
	                                return _context.abrupt("return", res.data.member && res.data.member.id ? res.data.member.id !== "" : false);

	                            case 4:
	                            case "end":
	                                return _context.stop();
	                        }
	                    }
	                }, null, _this);
	            });
	        }

	        /**
	         * Resolve an alias to a member
	         *
	         * @param {Object} alias - alias to lookup
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} result - TokenMember protobuf object
	         */

	    }, {
	        key: "resolveAlias",
	        value: function resolveAlias(alias, realm) {
	            var _this2 = this;

	            return _Util2.default.callAsync(this.resolveAlias, function _callee2() {
	                var res;
	                return regeneratorRuntime.async(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                _context2.next = 2;
	                                return regeneratorRuntime.awrap(_this2._unauthenticatedClient.resolveAlias(alias, realm));

	                            case 2:
	                                res = _context2.sent;
	                                return _context2.abrupt("return", res.data.member);

	                            case 4:
	                            case "end":
	                                return _context2.stop();
	                        }
	                    }
	                }, null, _this2);
	            });
	        }

	        /**
	         * Creates a member with a alias and a keypair, using the provided engine and member type.
	         *
	         * @param  {Object} alias - alias to set for member,
	         *                  falsy value or empty object for a temporary member without an alias
	         * @param  {Class} CryptoEngine - engine to use for key creation and storage
	         * @param  {String} memberType - type of member to create. "PERSONAL" if undefined
	         * @param  {String} realm - (optional) realm of the alias
	         * @return {Promise} member - Promise of created Member
	         */

	    }, {
	        key: "createMember",
	        value: function createMember(alias, CryptoEngine, memberType, realm) {
	            var _this3 = this;

	            return _Util2.default.callAsync(this.createMember, function _callee3() {
	                var response, engine, pk1, pk2, pk3, member;
	                return regeneratorRuntime.async(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                _context3.next = 2;
	                                return regeneratorRuntime.awrap(_this3._unauthenticatedClient.createMemberId(memberType));

	                            case 2:
	                                response = _context3.sent;
	                                engine = new CryptoEngine(response.data.memberId);
	                                _context3.next = 6;
	                                return regeneratorRuntime.awrap(engine.generateKey('PRIVILEGED'));

	                            case 6:
	                                pk1 = _context3.sent;
	                                _context3.next = 9;
	                                return regeneratorRuntime.awrap(engine.generateKey('STANDARD'));

	                            case 9:
	                                pk2 = _context3.sent;
	                                _context3.next = 12;
	                                return regeneratorRuntime.awrap(engine.generateKey('LOW'));

	                            case 12:
	                                pk3 = _context3.sent;
	                                _context3.next = 15;
	                                return regeneratorRuntime.awrap(_this3._unauthenticatedClient.approveFirstKeys(response.data.memberId, [pk1, pk2, pk3], engine));

	                            case 15:
	                                member = new _Member2.default(_this3._env, response.data.memberId, engine, _this3._developerKey, _this3._globalRpcErrorCallback, _this3._loggingEnabled, _this3._customSdkUrl);

	                                if (!(alias && Object.keys(alias).length !== 0)) {
	                                    _context3.next = 19;
	                                    break;
	                                }

	                                _context3.next = 19;
	                                return regeneratorRuntime.awrap(member.addAlias(alias, realm));

	                            case 19:
	                                return _context3.abrupt("return", member);

	                            case 20:
	                            case "end":
	                                return _context3.stop();
	                        }
	                    }
	                }, null, _this3);
	            });
	        }

	        /**
	         * Creates a member with a alias and a keypair, using the provided engine
	         *
	         * @param  {Object} alias - alias to set for member,
	         *                  falsy value or empty object for a temporary member without an alias
	         * @param  {Class} CryptoEngine - engine to use for key creation and storage
	         * @param  {string} realm - (optional) realm of the alias
	         * @return {Promise} member - Promise of created Member
	         */

	    }, {
	        key: "createBusinessMember",
	        value: function createBusinessMember(alias, CryptoEngine, realm) {
	            return this.createMember(alias, CryptoEngine, "BUSINESS", realm);
	        }

	        /**
	         * Provisions a new device for an existing user. The call generates a set
	         * of keys that are returned back. The keys need to be approved by an
	         * existing device/keys.
	         *
	         * @param {string} alias - user to provision the device for
	         * @param  {Class} CryptoEngine - engine to use for key creation and storage
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} deviceInfo - information about the device provisioned
	         */

	    }, {
	        key: "provisionDevice",
	        value: function provisionDevice(alias, CryptoEngine, realm) {
	            var _this4 = this;

	            return _Util2.default.callAsync(this.provisionDevice, function _callee4() {
	                var res, engine, pk1, pk2, pk3;
	                return regeneratorRuntime.async(function _callee4$(_context4) {
	                    while (1) {
	                        switch (_context4.prev = _context4.next) {
	                            case 0:
	                                _context4.next = 2;
	                                return regeneratorRuntime.awrap(_this4._unauthenticatedClient.resolveAlias(alias, realm));

	                            case 2:
	                                res = _context4.sent;

	                                if (!(!res.data.member || !res.data.member.id)) {
	                                    _context4.next = 5;
	                                    break;
	                                }

	                                throw new Error('Invalid alias');

	                            case 5:
	                                engine = new CryptoEngine(res.data.member.id);
	                                _context4.next = 8;
	                                return regeneratorRuntime.awrap(engine.generateKey('PRIVILEGED'));

	                            case 8:
	                                pk1 = _context4.sent;
	                                _context4.next = 11;
	                                return regeneratorRuntime.awrap(engine.generateKey('STANDARD'));

	                            case 11:
	                                pk2 = _context4.sent;
	                                _context4.next = 14;
	                                return regeneratorRuntime.awrap(engine.generateKey('LOW'));

	                            case 14:
	                                pk3 = _context4.sent;
	                                return _context4.abrupt("return", {
	                                    memberId: res.data.member.id,
	                                    keys: [pk1, pk2, pk3]
	                                });

	                            case 16:
	                            case "end":
	                                return _context4.stop();
	                        }
	                    }
	                }, null, _this4);
	            });
	        }

	        /**
	         * Provisions a new device for an existing user. The call generates a set
	         * of keys that are returned back. The keys need to be approved by an
	         * existing device/keys. This only generates one (LOW) key.
	         *
	         * @param {string} alias - user to provision the device for
	         * @param  {Class} CryptoEngine - engine to use for key creation and storage
	         * @param {string} realm - (optional) realm of the alias
	         * @param {number} expirationMs - (optional) expiration duration of key in milliseconds
	         * @return {Promise} deviceInfo - information about the device provisioned
	         */

	    }, {
	        key: "provisionDeviceLow",
	        value: function provisionDeviceLow(alias, CryptoEngine, realm) {
	            var _this5 = this;

	            var expirationMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _config2.default.lowKeyExpiration;

	            return _Util2.default.callAsync(this.provisionDeviceLow, function _callee5() {
	                var res, engine, pk1;
	                return regeneratorRuntime.async(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                                _context5.next = 2;
	                                return regeneratorRuntime.awrap(_this5._unauthenticatedClient.resolveAlias(alias, realm));

	                            case 2:
	                                res = _context5.sent;

	                                if (!(!res.data.member || !res.data.member.id)) {
	                                    _context5.next = 5;
	                                    break;
	                                }

	                                throw new Error('Invalid alias');

	                            case 5:
	                                engine = new CryptoEngine(res.data.member.id);
	                                _context5.next = 8;
	                                return regeneratorRuntime.awrap(engine.generateKey('LOW', expirationMs));

	                            case 8:
	                                pk1 = _context5.sent;
	                                return _context5.abrupt("return", {
	                                    memberId: res.data.member.id,
	                                    keys: [pk1]
	                                });

	                            case 10:
	                            case "end":
	                                return _context5.stop();
	                        }
	                    }
	                }, null, _this5);
	            });
	        }

	        /**
	         * Returns "logged-in" member that uses keys already in the CryptoEngine.
	         * If memberId is not provided, the last member to "log in" will be used.
	         *
	         * @param  {Class} CryptoEngine - engine to use for key creation and storage
	         * @param {string} memberId - optional id of the member we want to log in
	         * @return {Promise} member - instantiated member
	         */

	    }, {
	        key: "getMember",
	        value: function getMember(CryptoEngine, memberId) {
	            var _this6 = this;

	            return _Util2.default.callSync(this.getMember, function () {
	                if (!memberId && typeof CryptoEngine.getActiveMemberId === 'function') {
	                    memberId = CryptoEngine.getActiveMemberId();
	                }
	                var engine = new CryptoEngine(memberId);
	                return new _Member2.default(_this6._env, memberId, engine, _this6._developerKey, _this6._globalRpcErrorCallback, _this6._loggingEnabled, _this6._customSdkUrl);
	            });
	        }

	        /**
	         * Notifies subscribers that accounts should be linked, and passes the bank id and
	         * payload
	         *
	         * @param {Object} alias - alias to notify
	         * @param {string} bankAuthorization - bankAuthorization retrieved from bank
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} NotifyStatus - status
	         */

	    }, {
	        key: "notifyLinkAccounts",
	        value: function notifyLinkAccounts(alias, bankAuthorization, realm) {
	            var _this7 = this;

	            var body = {
	                linkAccounts: {
	                    bankAuthorization: bankAuthorization
	                }
	            };
	            return _Util2.default.callAsync(this.notifyLinkAccounts, function _callee6() {
	                var res;
	                return regeneratorRuntime.async(function _callee6$(_context6) {
	                    while (1) {
	                        switch (_context6.prev = _context6.next) {
	                            case 0:
	                                _context6.next = 2;
	                                return regeneratorRuntime.awrap(_this7._unauthenticatedClient.notify(alias, body, realm));

	                            case 2:
	                                res = _context6.sent;
	                                return _context6.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context6.stop();
	                        }
	                    }
	                }, null, _this7);
	            });
	        }

	        /**
	         * Notifies subscribers that a key should be added and passes the public Key and
	         * optional name
	         *
	         * @param {Object} alias - alias to notify
	         * @param {string} keyName - name for the new key, (e.g Chrome 53.0)
	         * @param {Object} key - key
	         * @param {string} level - key level
	         * @param {string} expiresMs - when the UI will time out
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} NotifyStatus - status
	         */

	    }, {
	        key: "notifyAddKey",
	        value: function notifyAddKey(alias, keyName, key, level, expiresMs, realm) {
	            var _this8 = this;

	            var body = {
	                addKey: {
	                    name: keyName,
	                    expiresMs: expiresMs,
	                    key: _extends({
	                        id: key.id,
	                        level: level,
	                        algorithm: key.algorithm,
	                        publicKey: _Crypto2.default.strKey(key.publicKey)
	                    }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs })
	                }
	            };
	            return _Util2.default.callAsync(this.notifyAddKey, function _callee7() {
	                var res;
	                return regeneratorRuntime.async(function _callee7$(_context7) {
	                    while (1) {
	                        switch (_context7.prev = _context7.next) {
	                            case 0:
	                                _context7.next = 2;
	                                return regeneratorRuntime.awrap(_this8._unauthenticatedClient.notify(alias, body, realm));

	                            case 2:
	                                res = _context7.sent;
	                                return _context7.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context7.stop();
	                        }
	                    }
	                }, null, _this8);
	            });
	        }

	        /**
	         * Notifies subscribed devices that accounts should be linked, and passes the bank id and
	         * payload
	         *
	         * @param {Object} alias - alias to notify
	         * @param {string} bankAuthorization - bankAuthorization retrieved from bank
	         * @param {string} keyName - name for the new key, (e.g Chrome 53.0)
	         * @param {Object} key - key
	         * @param {string} level - key level
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} NotifyStatus - status
	         */

	    }, {
	        key: "notifyLinkAccountsAndAddKey",
	        value: function notifyLinkAccountsAndAddKey(alias, bankAuthorization, keyName, key, level, realm) {
	            var _this9 = this;

	            var body = {
	                linkAccountsAndAddKey: {
	                    linkAccounts: {
	                        bankAuthorization: bankAuthorization
	                    },
	                    addKey: {
	                        name: keyName,
	                        key: _extends({
	                            id: key.id,
	                            level: level,
	                            algorithm: key.algorithm,
	                            publicKey: _Crypto2.default.strKey(key.publicKey)
	                        }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs })
	                    }
	                }
	            };
	            return _Util2.default.callAsync(this.notifyLinkAccountsAndAddKey, function _callee8() {
	                var res;
	                return regeneratorRuntime.async(function _callee8$(_context8) {
	                    while (1) {
	                        switch (_context8.prev = _context8.next) {
	                            case 0:
	                                _context8.next = 2;
	                                return regeneratorRuntime.awrap(_this9._unauthenticatedClient.notify(alias, body, realm));

	                            case 2:
	                                res = _context8.sent;
	                                return _context8.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context8.stop();
	                        }
	                    }
	                }, null, _this9);
	            });
	        }

	        /**
	         * Sends a notification to a user to request a payment.
	         *
	         * @param {Object} tokenPayload - requested transfer token
	         * @return {Promise} NotifyStatus - status
	         */

	    }, {
	        key: "notifyPaymentRequest",
	        value: function notifyPaymentRequest(tokenPayload) {
	            var _this10 = this;

	            if (!tokenPayload.refId) {
	                tokenPayload.refId = _Util2.default.generateNonce();
	            }
	            return _Util2.default.callAsync(this.notifyPaymentRequest, function _callee9() {
	                var res;
	                return regeneratorRuntime.async(function _callee9$(_context9) {
	                    while (1) {
	                        switch (_context9.prev = _context9.next) {
	                            case 0:
	                                _context9.next = 2;
	                                return regeneratorRuntime.awrap(_this10._unauthenticatedClient.notifyPaymentRequest(tokenPayload));

	                            case 2:
	                                res = _context9.sent;
	                                return _context9.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context9.stop();
	                        }
	                    }
	                }, null, _this10);
	            });
	        }

	        /**
	         * Notifies subscribed devices that a token payload should be endorsed and keys should be
	         * added.
	         *
	         * @param {Object} tokenPayload - the endorseAndAddKey payload to be sent
	         * @param {Array} keys - token keys to be added
	         * @param {Object} deviceMetadata - device metadata of the keys
	         * @param {string} tokenRequestId - (optional) token request Id
	         * @param {string} bankId - (optional) bank Id
	         * @param {string} state - (optional) token request state for signing
	         * @return {Promise} result - notification Id and notify status
	         */

	    }, {
	        key: "notifyEndorseAndAddKey",
	        value: function notifyEndorseAndAddKey(tokenPayload, keys, deviceMetadata, tokenRequestId, bankId, state) {
	            var _this11 = this;

	            var endorseAndAddKey = {
	                payload: tokenPayload,
	                addKey: {
	                    keys: keys,
	                    deviceMetadata: deviceMetadata
	                },
	                tokenRequestId: tokenRequestId,
	                bankId: bankId,
	                state: state
	            };
	            return _Util2.default.callAsync(this.notifyEndorseAndAddKey, function _callee10() {
	                var res;
	                return regeneratorRuntime.async(function _callee10$(_context10) {
	                    while (1) {
	                        switch (_context10.prev = _context10.next) {
	                            case 0:
	                                _context10.next = 2;
	                                return regeneratorRuntime.awrap(_this11._unauthenticatedClient.notifyEndorseAndAddKey(endorseAndAddKey));

	                            case 2:
	                                res = _context10.sent;
	                                return _context10.abrupt("return", {
	                                    notificationId: res.data.notificationId,
	                                    status: res.data.status
	                                });

	                            case 4:
	                            case "end":
	                                return _context10.stop();
	                        }
	                    }
	                }, null, _this11);
	            });
	        }

	        /**
	         * Invalidate a notification.
	         *
	         * @param {Object} notificationId - the notification id to invalidate
	         * @return {Promise} NotifyStatus - status
	         */

	    }, {
	        key: "invalidateNotification",
	        value: function invalidateNotification(notificationId) {
	            var _this12 = this;

	            return _Util2.default.callAsync(this.invalidateNotification, function _callee11() {
	                var res;
	                return regeneratorRuntime.async(function _callee11$(_context11) {
	                    while (1) {
	                        switch (_context11.prev = _context11.next) {
	                            case 0:
	                                _context11.next = 2;
	                                return regeneratorRuntime.awrap(_this12._unauthenticatedClient.invalidateNotification(notificationId));

	                            case 2:
	                                res = _context11.sent;
	                                return _context11.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context11.stop();
	                        }
	                    }
	                }, null, _this12);
	            });
	        }

	        /**
	         * Gets a list of available banks for linking
	         *
	         * @param {Object} options - optional parameters for getBanks
	         * @return {Promise} banks - list of banks
	         */

	    }, {
	        key: "getBanks",
	        value: function getBanks(options) {
	            var _this13 = this;

	            return _Util2.default.callAsync(this.getBanks, function _callee12() {
	                var res;
	                return regeneratorRuntime.async(function _callee12$(_context12) {
	                    while (1) {
	                        switch (_context12.prev = _context12.next) {
	                            case 0:
	                                _context12.next = 2;
	                                return regeneratorRuntime.awrap(_this13._unauthenticatedClient.getBanks(options));

	                            case 2:
	                                res = _context12.sent;
	                                return _context12.abrupt("return", res.data);

	                            case 4:
	                            case "end":
	                                return _context12.stop();
	                        }
	                    }
	                }, null, _this13);
	            });
	        }

	        /**
	         * Retrieves a request for a token. Called by the web(user) or by a TPP, to get request details.
	         *
	         * @param {string} requestId - token request id
	         * @return {Promise} TokenRequest - token request
	         */

	    }, {
	        key: "retrieveTokenRequest",
	        value: function retrieveTokenRequest(requestId) {
	            var _this14 = this;

	            return _Util2.default.callAsync(this.retrieveTokenRequest, function _callee13() {
	                var res;
	                return regeneratorRuntime.async(function _callee13$(_context13) {
	                    while (1) {
	                        switch (_context13.prev = _context13.next) {
	                            case 0:
	                                _context13.next = 2;
	                                return regeneratorRuntime.awrap(_this14._unauthenticatedClient.retrieveTokenRequest(requestId));

	                            case 2:
	                                res = _context13.sent;
	                                return _context13.abrupt("return", res.data.tokenRequest);

	                            case 4:
	                            case "end":
	                                return _context13.stop();
	                        }
	                    }
	                }, null, _this14);
	            });
	        }

	        /**
	         * Generate a token request authorization URL.
	         *
	         * @param {string} requestId - request id
	         * @param {string} state - original state
	         * @param {string} csrfToken - CSRF token
	         * @return {string} tokenRequestUrl - token request URL
	         */

	    }, {
	        key: "generateTokenRequestUrl",
	        value: function generateTokenRequestUrl(requestId) {
	            var _this15 = this;

	            var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
	            var csrfToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

	            return _Util2.default.callSync(this.generateTokenRequestUrl, function () {
	                var tokenRequestState = {
	                    csrfTokenHash: _Util2.default.hashString(csrfToken),
	                    innerState: state
	                };
	                var serializedState = encodeURIComponent(JSON.stringify(tokenRequestState));

	                return (_this15._customSdkUrl || _config2.default.webAppUrls[_this15._env]) + ("/request-token/" + requestId + "?state=" + serializedState);
	            });
	        }

	        /**
	         * Parse a token request callback URL, verify the state and signature,
	         * and return the inner state and token id.
	         *
	         * @param {string} callbackUrl - callback URL
	         * @param {string} csrfToken - CSRF token
	         * @return {Promise} result - inner state and token id
	         */

	    }, {
	        key: "parseTokenRequestCallbackUrl",
	        value: function parseTokenRequestCallbackUrl(callbackUrl) {
	            var _this16 = this;

	            var csrfToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

	            return _Util2.default.callAsync(this.parseTokenRequestCallbackUrl, function _callee14() {
	                var tokenMember, urlParams, params, signingKey;
	                return regeneratorRuntime.async(function _callee14$(_context14) {
	                    while (1) {
	                        switch (_context14.prev = _context14.next) {
	                            case 0:
	                                _context14.next = 2;
	                                return regeneratorRuntime.awrap(_this16._unauthenticatedClient.getTokenMember());

	                            case 2:
	                                tokenMember = _context14.sent;
	                                urlParams = _Util2.default.parseParamsFromUrl(callbackUrl);
	                                params = {
	                                    tokenId: decodeURIComponent(urlParams.tokenId),
	                                    state: JSON.parse(decodeURIComponent(urlParams.state)),
	                                    signature: JSON.parse(decodeURIComponent(urlParams.signature))
	                                };

	                                if (!(params.state.csrfTokenHash !== _Util2.default.hashString(csrfToken))) {
	                                    _context14.next = 7;
	                                    break;
	                                }

	                                throw new Error('Invalid state.');

	                            case 7:
	                                signingKey = _Util2.default.getSigningKey(tokenMember.keys, params.signature);
	                                _context14.next = 10;
	                                return regeneratorRuntime.awrap(_Crypto2.default.verifyJson({
	                                    state: encodeURIComponent(JSON.stringify(params.state)),
	                                    tokenId: params.tokenId
	                                }, params.signature.signature, _Crypto2.default.bufferKey(signingKey.publicKey)));

	                            case 10:
	                                return _context14.abrupt("return", {
	                                    tokenId: params.tokenId,
	                                    innerState: params.state.innerState
	                                });

	                            case 11:
	                            case "end":
	                                return _context14.stop();
	                        }
	                    }
	                }, null, _this16);
	            });
	        }

	        /**
	         * Get a token ID based on its token request ID.
	         *
	         * @param {string} tokenRequestId - token request id
	         * @return {Promise} tokenId - token id
	         */

	    }, {
	        key: "getTokenId",
	        value: function getTokenId(tokenRequestId) {
	            var _this17 = this;

	            return _Util2.default.callAsync(this.getTokenId, function _callee15() {
	                var res;
	                return regeneratorRuntime.async(function _callee15$(_context15) {
	                    while (1) {
	                        switch (_context15.prev = _context15.next) {
	                            case 0:
	                                _context15.next = 2;
	                                return regeneratorRuntime.awrap(_this17._unauthenticatedClient.getTokenId(tokenRequestId));

	                            case 2:
	                                res = _context15.sent;
	                                return _context15.abrupt("return", res.data.tokenId);

	                            case 4:
	                            case "end":
	                                return _context15.stop();
	                        }
	                    }
	                }, null, _this17);
	            });
	        }
	    }], [{
	        key: "enableIframePassthrough",
	        value: function enableIframePassthrough(env) {
	            _Util2.default.enableIframePassthrough(_config2.default.corsDomainSuffix, _config2.default.urls[env]);
	        }

	        /**
	         * If we're on a token page, this disables passthrough
	         */

	    }, {
	        key: "disableIframePassthrough",
	        value: function disableIframePassthrough() {
	            _Util2.default.disableIframePassthrough(_config2.default.corsDomainSuffix);
	        }
	    }]);

	    return Token;
	}();

	exports.default = Token;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _jsonStableStringify = __webpack_require__(5);

	var _jsonStableStringify2 = _interopRequireDefault(_jsonStableStringify);

	var _CryptoNode = __webpack_require__(6);

	var _CryptoNode2 = _interopRequireDefault(_CryptoNode);

	var _CryptoBrowser = __webpack_require__(15);

	var _CryptoBrowser2 = _interopRequireDefault(_CryptoBrowser);

	var _base64url = __webpack_require__(10);

	var _base64url2 = _interopRequireDefault(_base64url);

	var _buffer = __webpack_require__(12);

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CryptoLib =  false ? _CryptoBrowser2.default : _CryptoNode2.default;

	/**
	 * Class providing static crypto primitives.
	 */

	var Crypto = function () {
	    function Crypto() {
	        _classCallCheck(this, Crypto);
	    }

	    _createClass(Crypto, null, [{
	        key: "generateKeys",

	        /**
	         * Generates a key pair to use with the Token system.
	         *
	         * @param {string} keyLevel - "LOW", "STANDARD", or "PRIVILEGED"
	         * @param {number} expirationMs - (optional) expiration duration of the key in milliseconds
	         * @param {boolean} extractable - whether the private key can be extracted into raw data
	         * @return {Object} generated key pair
	         */
	        value: function generateKeys(keyLevel, expirationMs, extractable) {
	            return regeneratorRuntime.async(function generateKeys$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return regeneratorRuntime.awrap(CryptoLib.generateKeys(keyLevel, expirationMs, extractable));

	                        case 2:
	                            return _context.abrupt("return", _context.sent);

	                        case 3:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Signs a json object and returns the signature
	         *
	         * @param {Object} json - object to sign
	         * @param {Object} keys - keys to sign with
	         * @return {string} signature
	         */

	    }, {
	        key: "signJson",
	        value: function signJson(json, keys) {
	            return regeneratorRuntime.async(function signJson$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return regeneratorRuntime.awrap(Crypto.sign((0, _jsonStableStringify2.default)(json), keys));

	                        case 2:
	                            return _context2.abrupt("return", _context2.sent);

	                        case 3:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Signs a string and returns the signature.
	         *
	         * @param {string} message - message to sign
	         * @param {Object} keys - keys to sign with
	         * @return {string} signature
	         */

	    }, {
	        key: "sign",
	        value: function sign(message, keys) {
	            return regeneratorRuntime.async(function sign$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.next = 2;
	                            return regeneratorRuntime.awrap(CryptoLib.sign(message, keys));

	                        case 2:
	                            return _context3.abrupt("return", _context3.sent);

	                        case 3:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Helper function for crypto engine createSigner:
	         * returns a signer that uses a key pair.
	         *
	         * @param {Object} keyPair - such as returned by Token.Crypto.generateKeys
	         * @return {Object} signer object
	         */

	    }, {
	        key: "createSignerFromKeypair",
	        value: function createSignerFromKeypair(keyPair) {
	            var _this = this;

	            return {
	                sign: function sign(message) {
	                    return regeneratorRuntime.async(function sign$(_context4) {
	                        while (1) {
	                            switch (_context4.prev = _context4.next) {
	                                case 0:
	                                    _context4.next = 2;
	                                    return regeneratorRuntime.awrap(Crypto.sign(message, keyPair));

	                                case 2:
	                                    return _context4.abrupt("return", _context4.sent);

	                                case 3:
	                                case "end":
	                                    return _context4.stop();
	                            }
	                        }
	                    }, null, _this);
	                },
	                signJson: function signJson(json) {
	                    return regeneratorRuntime.async(function signJson$(_context5) {
	                        while (1) {
	                            switch (_context5.prev = _context5.next) {
	                                case 0:
	                                    _context5.next = 2;
	                                    return regeneratorRuntime.awrap(Crypto.signJson(json, keyPair));

	                                case 2:
	                                    return _context5.abrupt("return", _context5.sent);

	                                case 3:
	                                case "end":
	                                    return _context5.stop();
	                            }
	                        }
	                    }, null, _this);
	                },
	                getKeyId: function getKeyId() {
	                    return keyPair.id;
	                }
	            };
	        }

	        /**
	         * Verifies a signature on a JSON object. Throws if verification fails.
	         *
	         * @param {Object} json - JSON object to verify
	         * @param {string} signature - signature to verify
	         * @param {Uint8Array} publicKey - public key to use for verification
	         */

	    }, {
	        key: "verifyJson",
	        value: function verifyJson(json, signature, publicKey) {
	            return regeneratorRuntime.async(function verifyJson$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	                            _context6.next = 2;
	                            return regeneratorRuntime.awrap(Crypto.verify((0, _jsonStableStringify2.default)(json), signature, publicKey));

	                        case 2:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Verifies a signature on a string. Throws if verification fails.
	         *
	         * @param {string} message - string to verify
	         * @param {string} signature - signature to verify
	         * @param {Uint8Array} publicKey - public key to use for verification
	         */

	    }, {
	        key: "verify",
	        value: function verify(message, signature, publicKey) {
	            return regeneratorRuntime.async(function verify$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.next = 2;
	                            return regeneratorRuntime.awrap(CryptoLib.verify(message, signature, publicKey));

	                        case 2:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Helper function for crypto engine createVerifier:
	         * returns a signer that uses a key pair.
	         *
	         * @param {Object} keyPair - such as returned by Token.Crypto.generateKeys, private key optional
	         * @return {Object} verifier object
	         */

	    }, {
	        key: "createVerifierFromKeypair",
	        value: function createVerifierFromKeypair(keyPair) {
	            var _this2 = this;

	            return {
	                verify: function verify(message, signature) {
	                    return regeneratorRuntime.async(function verify$(_context8) {
	                        while (1) {
	                            switch (_context8.prev = _context8.next) {
	                                case 0:
	                                    _context8.next = 2;
	                                    return regeneratorRuntime.awrap(Crypto.verify(message, signature, keyPair.publicKey));

	                                case 2:
	                                    return _context8.abrupt("return", _context8.sent);

	                                case 3:
	                                case "end":
	                                    return _context8.stop();
	                            }
	                        }
	                    }, null, _this2);
	                },
	                verifyJson: function verifyJson(json, signature) {
	                    return regeneratorRuntime.async(function verifyJson$(_context9) {
	                        while (1) {
	                            switch (_context9.prev = _context9.next) {
	                                case 0:
	                                    _context9.next = 2;
	                                    return regeneratorRuntime.awrap(Crypto.verifyJson(json, signature, keyPair.publicKey));

	                                case 2:
	                                    return _context9.abrupt("return", _context9.sent);

	                                case 3:
	                                case "end":
	                                    return _context9.stop();
	                            }
	                        }
	                    }, null, _this2);
	                }
	            };
	        }

	        /**
	         * Converts a key to string.
	         *
	         * @param {Uint8Array} key - key to encode
	         * @return {string} encoded key
	         */

	    }, {
	        key: "strKey",
	        value: function strKey(key) {
	            return (0, _base64url2.default)(key);
	        }

	        /**
	         * Wraps buffer as an Uint8Array object.
	         *
	         * @param {string|Buffer} buffer - data
	         * @return {Uint8Array} data
	         */

	    }, {
	        key: "wrapBuffer",
	        value: function wrapBuffer(buffer) {
	            return new Uint8Array(new _buffer.Buffer(buffer));
	        }

	        /**
	         * Converts a key from a string to buffer.
	         *
	         * @param {string} key - base64Url encoded key
	         * @return {Uint8Array} buffered key
	         */

	    }, {
	        key: "bufferKey",
	        value: function bufferKey(key) {
	            return Crypto.wrapBuffer(_base64url2.default.toBuffer(key));
	        }
	    }]);

	    return Crypto;
	}();

	exports.default = Crypto;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = require("json-stable-stringify");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	var _base64url = __webpack_require__(13);

	var _base64url2 = _interopRequireDefault(_base64url);

	var _tweetnacl = __webpack_require__(14);

	var _tweetnacl2 = _interopRequireDefault(_tweetnacl);

	var _fastSha = __webpack_require__(9);

	var _fastSha2 = _interopRequireDefault(_fastSha);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Class providing static crypto primitives for Node environments using libsodium.
	 */
	var CryptoNode = function () {
	    function CryptoNode() {
	        _classCallCheck(this, CryptoNode);
	    }

	    _createClass(CryptoNode, null, [{
	        key: "generateKeys",

	        /**
	         * Generates a key pair to use with the Token system.
	         *
	         * @param {string} keyLevel - "LOW", "STANDARD", or "PRIVILEGED"
	         * @param {number} expirationMs - (optional) expiration duration of the key in milliseconds
	         * @param {boolean} extractable - whether the private key can be extracted into raw data
	         * @return {Object} generated key pair
	         */
	        value: function generateKeys(keyLevel, expirationMs) {
	            var extractable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	            var keyPair;
	            return regeneratorRuntime.async(function generateKeys$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            keyPair = _tweetnacl2.default.sign.keyPair();

	                            keyPair.id = (0, _base64url2.default)((0, _fastSha2.default)(keyPair.publicKey)).substring(0, 16);
	                            keyPair.algorithm = 'ED25519';
	                            keyPair.level = keyLevel;
	                            keyPair.privateKey = keyPair.secretKey;
	                            if (expirationMs !== undefined) keyPair.expiresAtMs = new Date().getTime() + expirationMs;
	                            delete keyPair.secretKey;
	                            return _context.abrupt("return", keyPair);

	                        case 8:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Signs a string and returns the signature.
	         *
	         * @param {string} message - message to sign
	         * @param {Object} keys - keys to sign with
	         * @return {string} signature
	         */

	    }, {
	        key: "sign",
	        value: function sign(message, keys) {
	            var msg;
	            return regeneratorRuntime.async(function sign$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            msg = _Util2.default.wrapBuffer(message);
	                            return _context2.abrupt("return", (0, _base64url2.default)(_tweetnacl2.default.sign.detached(msg, keys.privateKey)));

	                        case 2:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Verifies a signature on a string. Throws if verification fails.
	         *
	         * @param {string} message - string to verify
	         * @param {string} signature - signature to verify
	         * @param {Uint8Array} publicKey - public key to use for verification
	         */

	    }, {
	        key: "verify",
	        value: function verify(message, signature, publicKey) {
	            var msg, sig, result;
	            return regeneratorRuntime.async(function verify$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            msg = _Util2.default.wrapBuffer(message);
	                            sig = _Util2.default.bufferKey(signature);
	                            result = _tweetnacl2.default.sign.detached.verify(msg, sig, publicKey);

	                            if (result) {
	                                _context3.next = 5;
	                                break;
	                            }

	                            throw new Error("Invalid signature " + signature + " on message " + message + " with pk " + publicKey);

	                        case 5:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return CryptoNode;
	}();

	exports.default = CryptoNode;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Class to provide static utility functions.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _bs = __webpack_require__(8);

	var _bs2 = _interopRequireDefault(_bs);

	var _fastSha = __webpack_require__(9);

	var _fastSha2 = _interopRequireDefault(_fastSha);

	var _jsonStableStringify = __webpack_require__(5);

	var _jsonStableStringify2 = _interopRequireDefault(_jsonStableStringify);

	var _base64url = __webpack_require__(10);

	var _base64url2 = _interopRequireDefault(_base64url);

	var _buffer = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Util = function () {
	    function Util() {
	        _classCallCheck(this, Util);
	    }

	    _createClass(Util, null, [{
	        key: "generateNonce",

	        /**
	         * Generates a random nonce
	         *
	         * @return {string} nonce - random string
	         */
	        value: function generateNonce() {
	            return Math.random().toString(36).slice(-9) + Math.random().toString(36).slice(-9);
	        }

	        /**
	         * Generates a random alias. Handy for tests.
	         *
	         * @return {Object} alias protobuf
	         */

	    }, {
	        key: "randomAlias",
	        value: function randomAlias() {
	            return {
	                type: 'EMAIL',
	                value: 'test-' + Util.generateNonce() + '+noverify@example.com'
	            };
	        }

	        /**
	         * Returns the token alias.
	         *
	         * @return {Object} token alias protobuf
	         */

	    }, {
	        key: "tokenAlias",
	        value: function tokenAlias() {
	            return {
	                type: 'DOMAIN',
	                value: 'token.io'
	            };
	        }

	        /**
	         * Returns the token realm.
	         *
	         * @return {string} token realm
	         */

	    }, {
	        key: "tokenRealm",
	        value: function tokenRealm() {
	            return 'token';
	        }

	        /**
	         * Tests if a string ends with a suffix,
	         *
	         * @param {string} str - the string to test
	         * @param {string} suffix - the suffix to test
	         * @return {boolean} endsWith - true if it does
	         */

	    }, {
	        key: "stringEndsWith",
	        value: function stringEndsWith(str, suffix) {
	            if (str === null || str === '' || suffix === null || suffix === '') {
	                return false;
	            }
	            str = str.toString();
	            suffix = suffix.toString();
	            return str.indexOf(suffix, str.length - suffix.length) !== -1;
	        }

	        /**
	         * Gets the specified byte of the 4 byte word, according to index. Assumes 2s complement
	         * representation of the word
	         *
	         * @param {number} word - 32 bit value number, in 2s complement
	         * @param {number} index - index of the byte to return
	         * @return {number} result - the desired byte [0, 255]
	         */

	    }, {
	        key: "getByte",
	        value: function getByte(word, index) {
	            if (index === 0) {
	                return word & (1 << 8) - 1;
	            } else if (index === 1) {
	                return (word & (1 << 16) - 1) >> 8;
	            } else if (index === 2) {
	                return (word & (1 << 24) - 1) >> 16;
	            }
	            var temp = (word & (1 << 8) - 1 << 24) >> 24;
	            return temp < 0 ? 256 + temp : temp;
	        }

	        /**
	         * Count the number of decimal points in a number
	         *
	         * @param {Number} value - number
	         * @return {Number} count - number of decimals
	         */

	    }, {
	        key: "countDecimals",
	        value: function countDecimals(value) {
	            if (Math.floor(value) === value) {
	                return 0;
	            }
	            return value.toString().split(".")[1].length || 0;
	        }

	        /**
	         * Helper method to handle promise exceptions. The function will be executed, and if
	         * anything fails, a rejected promise is returned, with the method name that failed,
	         * included in the rejection.
	         *
	         * @param {function} method - outside method that is being executed
	         * @param {function} fn - function to try to execute
	         * @return {Promise} promise - successful or rejected promise
	         */

	    }, {
	        key: "callAsync",
	        value: function callAsync(method, fn) {
	            var reason;
	            return regeneratorRuntime.async(function callAsync$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.prev = 0;
	                            _context.next = 3;
	                            return regeneratorRuntime.awrap(fn());

	                        case 3:
	                            return _context.abrupt("return", _context.sent);

	                        case 6:
	                            _context.prev = 6;
	                            _context.t0 = _context["catch"](0);
	                            reason = _context.t0.response !== undefined && _context.t0.response.data !== undefined ? _context.t0.response.data : "UNKNOWN";

	                            _context.t0.info = method.name + ': ' + _context.t0.message + '. Reason: ' + reason;
	                            return _context.abrupt("return", Promise.reject(_context.t0));

	                        case 11:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this, [[0, 6]]);
	        }

	        /**
	         * Helper method similar to the one above, but without promises
	         *
	         * @param {function} method - outside method that is being executed
	         * @param {function} fn - function to try to execute
	         * @return {Object} result - successful result or thrown error
	         */

	    }, {
	        key: "callSync",
	        value: function callSync(method, fn) {
	            try {
	                return fn();
	            } catch (err) {
	                var reason = err.response !== undefined && err.response.data !== undefined ? err.response.data : "UNKNOWN";
	                err.info = method.name + ': ' + err.message + '. Reason: ' + reason;
	                throw err;
	            }
	        }

	        /**
	         * Support alias hashing
	         *
	         * @param {Object} alias - alias to be hashed
	         * @return {String} result - hashed alias
	         * TODO(PR-1138): remove username support
	         */

	    }, {
	        key: "hashAndSerializeAlias",
	        value: function hashAndSerializeAlias(alias) {
	            if (alias.type === 'USERNAME') {
	                return alias.value;
	            }
	            return _bs2.default.encode((0, _fastSha2.default)(Buffer.from((0, _jsonStableStringify2.default)(alias), 'utf8')));
	        }

	        /**
	         * Hash a string value.
	         *
	         * @param {string} value - value to be hahsed
	         * @return {string} result - hashed value
	         */

	    }, {
	        key: "hashString",
	        value: function hashString(value) {
	            return _bs2.default.encode((0, _fastSha2.default)(Buffer.from(value, 'utf8')));
	        }

	        /**
	         * If we're on a token page, sets up an iframe to avoid CORS preflights. All requests in this
	         * window will be routed through the iframe.
	         *
	         * @param {string} suffix - domain suffix for Iframe passthrough
	         * @param {string} url - base url for the API gateway
	         */

	    }, {
	        key: "enableIframePassthrough",
	        value: function enableIframePassthrough(suffix, url) {
	            if (false) {
	                var setupAPI = function setupAPI() {
	                    window.oldXMLHttpRequest = window.XMLHttpRequest;
	                    window.oldFetch = window.fetch;
	                    window.XMLHttpRequest = this.contentWindow.XMLHttpRequest;
	                    window.fetch = this.contentWindow.fetch;
	                };

	                var iframe = document.getElementById('tokenApiIframe');
	                if (iframe === null) {
	                    iframe = document.createElement('iframe');
	                    iframe.id = 'tokenApiIframe';
	                    iframe.src = url + '/iframe';
	                    iframe.style.position = 'absolute';
	                    iframe.style.left = '-9999px';
	                    iframe.onload = setupAPI;
	                    document.body.appendChild(iframe);
	                }
	            }
	        }

	        /**
	         * If we're on a token page, this disables passthrough
	         *
	         * @param {string} suffix - domain suffix for Iframe passthrough
	         */

	    }, {
	        key: "disableIframePassthrough",
	        value: function disableIframePassthrough(suffix) {
	            if (false) {
	                if (window.oldXMLHttpRequest) {
	                    window.XMLHttpRequest = window.oldXMLHttpRequest;
	                }
	                if (window.oldFetch) {
	                    window.fetch = window.oldFetch;
	                }
	                var iframe = document.getElementById('tokenApiIframe');
	                if (iframe !== null) {
	                    document.body.removeChild(iframe);
	                }
	            }
	        }

	        /**
	         * Gets the signing key from a list of keys corresponding to the signature.
	         *
	         * @param {Array} keys -  list of keys
	         * @param {Object} signature - signature
	         * @return {Object} key - the signing key
	         */

	    }, {
	        key: "getSigningKey",
	        value: function getSigningKey(keys, signature) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var key = _step.value;

	                    if (key.id === signature.keyId) {
	                        return key;
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }

	            throw new Error('Invalid signature');
	        }

	        /**
	         * Converts a key to string.
	         *
	         * @param {Uint8Array} key - key to encode
	         * @return {string} encoded key
	         */

	    }, {
	        key: "strKey",
	        value: function strKey(key) {
	            return (0, _base64url2.default)(key);
	        }

	        /**
	         * Wraps buffer as an Uint8Array object.
	         *
	         * @param {string|Buffer} buffer - data
	         * @return {Uint8Array} data
	         */

	    }, {
	        key: "wrapBuffer",
	        value: function wrapBuffer(buffer) {
	            return new Uint8Array(new _buffer.Buffer(buffer));
	        }

	        /**
	         * Converts a key from a string to buffer.
	         *
	         * @param {string} key - base64Url encoded key
	         * @return {Uint8Array} buffered key
	         */

	    }, {
	        key: "bufferKey",
	        value: function bufferKey(key) {
	            return Util.wrapBuffer(_base64url2.default.toBuffer(key));
	        }

	        /**
	         * Converts a key to a token key.
	         *
	         * @param {Object} key - key
	         * @param {string} level - key level
	         * @return {Object} token key
	         */

	    }, {
	        key: "tokenKey",
	        value: function tokenKey(key, level) {
	            return _extends({
	                id: key.id,
	                level: level,
	                algorithm: key.algorithm,
	                publicKey: Util.strKey(key.publicKey)
	            }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs });
	        }
	    }, {
	        key: "parseParamsFromUrl",
	        value: function parseParamsFromUrl(url) {
	            var query = url.split('?')[1];
	            var result = {};
	            query.split("&").forEach(function (part) {
	                var item = part.split("=");
	                result[item[0]] = decodeURIComponent(item[1]);
	            });
	            return result;
	        }
	    }, {
	        key: "setUpHttpErrorLogging",
	        value: function setUpHttpErrorLogging(instance) {
	            instance.interceptors.response.use(function (res) {
	                return res;
	            }, function (err) {
	                console.log(err.response);
	                return Promise.reject(err);
	            });
	        }
	    }, {
	        key: "isFirefox",
	        value: function isFirefox() {
	            return (false) && typeof window.InstallTrigger !== 'undefined';
	        }
	    }, {
	        key: "isIE11",
	        value: function isIE11() {
	            return (false) && window.MSInputMethodContext && document.documentMode;
	        }
	    }, {
	        key: "isEdge",
	        value: function isEdge() {
	            return (false) && /Edge/.test(window.navigator.userAgent);
	        }
	    }]);

	    return Util;
	}();

	exports.default = Util;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = require("bs58");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = require("fast-sha256");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var pad_string_1 = __webpack_require__(11);
	function encode(input, encoding) {
	    if (encoding === void 0) { encoding = "utf8"; }
	    if (Buffer.isBuffer(input)) {
	        return fromBase64(input.toString("base64"));
	    }
	    return fromBase64(new Buffer(input, encoding).toString("base64"));
	}
	;
	function decode(base64url, encoding) {
	    if (encoding === void 0) { encoding = "utf8"; }
	    return new Buffer(toBase64(base64url), "base64").toString(encoding);
	}
	function toBase64(base64url) {
	    base64url = base64url.toString();
	    return pad_string_1.default(base64url)
	        .replace(/\-/g, "+")
	        .replace(/_/g, "/");
	}
	function fromBase64(base64) {
	    return base64
	        .replace(/=/g, "")
	        .replace(/\+/g, "-")
	        .replace(/\//g, "_");
	}
	function toBuffer(base64url) {
	    return new Buffer(toBase64(base64url), "base64");
	}
	var base64url = encode;
	base64url.encode = encode;
	base64url.decode = decode;
	base64url.toBase64 = toBase64;
	base64url.fromBase64 = fromBase64;
	base64url.toBuffer = toBuffer;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = base64url;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	"use strict";
	function padString(input) {
	    var segmentLength = 4;
	    var stringLength = input.length;
	    var diff = stringLength % segmentLength;
	    if (!diff) {
	        return input;
	    }
	    var position = stringLength;
	    var padLength = segmentLength - diff;
	    var paddedStringLength = stringLength + padLength;
	    var buffer = new Buffer(paddedStringLength);
	    buffer.write(input);
	    while (padLength--) {
	        buffer.write("=", position++);
	    }
	    return buffer.toString();
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = padString;


/***/ }),
/* 12 */
/***/ (function(module, exports) {

	module.exports = require("buffer");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = require("base64url");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	module.exports = require("tweetnacl");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _base64url = __webpack_require__(13);

	var _base64url2 = _interopRequireDefault(_base64url);

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var crypto = (false) && window.crypto;

	// supported algorithms
	var ECDSA = 'ECDSA_SHA256';
	var RSA = 'RS256';

	var algorithm = _Util2.default.isFirefox || _Util2.default.isEdge() ? RSA : ECDSA; // default to ECDSA and fallback to RSA

	/**
	 * Class providing static crypto primitives for the browser using Web Cryptography API.
	 */

	var CryptoBrowser = function () {
	    function CryptoBrowser() {
	        _classCallCheck(this, CryptoBrowser);
	    }

	    _createClass(CryptoBrowser, null, [{
	        key: 'generateKeys',

	        /**
	         * Generates a key pair to use with the Token system.
	         *
	         * @param {string} keyLevel - "LOW", "STANDARD", or "PRIVILEGED"
	         * @param {string} expirationMs - (optional) expiration duration of the key in milliseconds
	         * @param {boolean} extractable - whether the private key can be extracted into raw data
	         * @return {Object} generated key pair
	         */
	        value: function generateKeys(keyLevel, expirationMs) {
	            var extractable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	            var keyPair;
	            return regeneratorRuntime.async(function generateKeys$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return regeneratorRuntime.awrap(CryptoBrowser._generateKeyPair(extractable));

	                        case 2:
	                            keyPair = _context.sent;

	                            keyPair.level = keyLevel;
	                            if (expirationMs !== undefined) keyPair.expiresAtMs = new Date().getTime() + expirationMs;
	                            return _context.abrupt('return', keyPair);

	                        case 6:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Signs a string and returns the signature.
	         *
	         * @param {string} message - message to sign
	         * @param {Object} keys - keys to sign with
	         * @return {string} signature
	         */

	    }, {
	        key: 'sign',
	        value: function sign(message, keys) {
	            var importedPrivateKey, sig;
	            return regeneratorRuntime.async(function sign$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            importedPrivateKey = keys.privateKey;

	                            if (keys.privateKey.constructor.name === 'CryptoKey') {
	                                _context2.next = 5;
	                                break;
	                            }

	                            _context2.next = 4;
	                            return regeneratorRuntime.awrap(crypto.subtle.importKey('jwk', keys.privateKey, CryptoBrowser[algorithm].import, false, ['sign']));

	                        case 4:
	                            importedPrivateKey = _context2.sent;

	                        case 5:
	                            _context2.t0 = Uint8Array;
	                            _context2.next = 8;
	                            return regeneratorRuntime.awrap(crypto.subtle.sign(CryptoBrowser[algorithm].sign, importedPrivateKey, _Util2.default.wrapBuffer(message)));

	                        case 8:
	                            _context2.t1 = _context2.sent;
	                            sig = new _context2.t0(_context2.t1);

	                            if (algorithm === ECDSA) sig = CryptoBrowser._P1363ToDer(sig);
	                            return _context2.abrupt('return', (0, _base64url2.default)(sig));

	                        case 12:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Verifies a signature on a string. Throws if verification fails.
	         *
	         * @param {string} message - string to verify
	         * @param {string} signature - signature to verify
	         * @param {Uint8Array} publicKey - public key to use for verification
	         */

	    }, {
	        key: 'verify',
	        value: function verify(message, signature, publicKey) {
	            var importedPublicKey, result;
	            return regeneratorRuntime.async(function verify$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            signature = _Util2.default.bufferKey(signature);
	                            if (algorithm === ECDSA) signature = CryptoBrowser._DerToP1363(signature);
	                            _context3.next = 4;
	                            return regeneratorRuntime.awrap(crypto.subtle.importKey('spki', publicKey, CryptoBrowser[algorithm].import, false, ['verify']));

	                        case 4:
	                            importedPublicKey = _context3.sent;
	                            _context3.next = 7;
	                            return regeneratorRuntime.awrap(crypto.subtle.verify(CryptoBrowser[algorithm].verify, importedPublicKey, signature, _Util2.default.wrapBuffer(message)));

	                        case 7:
	                            result = _context3.sent;

	                            if (result) {
	                                _context3.next = 10;
	                                break;
	                            }

	                            throw new Error('Invalid signature ' + signature + ' on message ' + message + ' with pk ' + publicKey);

	                        case 10:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }, {
	        key: '_generateKeyPair',
	        value: function _generateKeyPair(extractable) {
	            var keyPair;
	            return regeneratorRuntime.async(function _generateKeyPair$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            keyPair = void 0;
	                            _context4.prev = 1;
	                            _context4.next = 4;
	                            return regeneratorRuntime.awrap(crypto.subtle.generateKey(CryptoBrowser[algorithm].generate, extractable, ['sign', 'verify']));

	                        case 4:
	                            keyPair = _context4.sent;
	                            _context4.next = 13;
	                            break;

	                        case 7:
	                            _context4.prev = 7;
	                            _context4.t0 = _context4['catch'](1);

	                            algorithm = RSA;
	                            _context4.next = 12;
	                            return regeneratorRuntime.awrap(crypto.subtle.generateKey(CryptoBrowser[algorithm].generate, extractable, ['sign', 'verify']));

	                        case 12:
	                            keyPair = _context4.sent;

	                        case 13:
	                            keyPair = { publicKey: keyPair.publicKey, privateKey: keyPair.privateKey }; // for MS Edge

	                            if (!extractable) {
	                                _context4.next = 18;
	                                break;
	                            }

	                            _context4.next = 17;
	                            return regeneratorRuntime.awrap(crypto.subtle.exportKey('jwk', keyPair.privateKey));

	                        case 17:
	                            keyPair.privateKey = _context4.sent;

	                        case 18:
	                            _context4.t1 = Uint8Array;
	                            _context4.next = 21;
	                            return regeneratorRuntime.awrap(crypto.subtle.exportKey('spki', keyPair.publicKey));

	                        case 21:
	                            _context4.t2 = _context4.sent;
	                            keyPair.publicKey = new _context4.t1(_context4.t2);
	                            _context4.t3 = _base64url2.default;
	                            _context4.next = 26;
	                            return regeneratorRuntime.awrap(crypto.subtle.digest('SHA-256', keyPair.publicKey));

	                        case 26:
	                            _context4.t4 = _context4.sent;
	                            keyPair.id = (0, _context4.t3)(_context4.t4).substring(0, 16);

	                            keyPair.algorithm = algorithm;
	                            return _context4.abrupt('return', keyPair);

	                        case 30:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, null, this, [[1, 7]]);
	        }

	        /**
	         * Converts an ECDSA signature from P1363 to DER format
	         *
	         * @param {Uint8Array} sig - P1363 signature
	         * @return {Uint8Array} DER signature
	         * @private
	         */

	    }, {
	        key: '_P1363ToDer',
	        value: function _P1363ToDer(sig) {
	            var signature = Array.from(sig, function (x) {
	                return ('00' + x.toString(16)).slice(-2);
	            }).join('');
	            var r = signature.substr(0, signature.length / 2);
	            var s = signature.substr(signature.length / 2);
	            r = r.replace(/^(00)+/, '');
	            s = s.replace(/^(00)+/, '');
	            if ((parseInt(r, 16) & '0x80') > 0) r = '00' + r;
	            if ((parseInt(s, 16) & '0x80') > 0) s = '00' + s;
	            var rString = '02' + (r.length / 2).toString(16).padStart(2, '0') + r;
	            var sString = '02' + (s.length / 2).toString(16).padStart(2, '0') + s;
	            var derSig = '30' + ((rString.length + sString.length) / 2).toString(16).padStart(2, '0') + rString + sString;
	            return new Uint8Array(derSig.match(/[\da-f]{2}/gi).map(function (h) {
	                return parseInt(h, 16);
	            }));
	        }

	        /**
	         * Converts an ECDSA signature from DER to P1363 format
	         *
	         * @param {Uint8Array} sig - DER signature
	         * @return {Uint8Array} P1363 signature
	         * @private
	         */

	    }, {
	        key: '_DerToP1363',
	        value: function _DerToP1363(sig) {
	            var signature = Array.from(sig, function (x) {
	                return ('00' + x.toString(16)).slice(-2);
	            }).join('');
	            var rLength = parseInt(signature.substr(6, 2), 16) * 2;
	            var r = signature.substr(8, rLength);
	            var s = signature.substr(12 + rLength);
	            r = r.length > 64 ? r.substr(-64) : r.padStart(64, '0');
	            s = s.length > 64 ? s.substr(-64) : s.padStart(64, '0');
	            var p1363Sig = '' + r + s;
	            return new Uint8Array(p1363Sig.match(/[\da-f]{2}/gi).map(function (h) {
	                return parseInt(h, 16);
	            }));
	        }
	    }, {
	        key: ECDSA,
	        get: function get() {
	            var ao = {}; // algorithm options
	            ao.generate = ao.import = {
	                name: "ECDSA",
	                namedCurve: "P-256" // can be "P-256", "P-384", or "P-521"
	            };
	            ao.sign = ao.verify = {
	                name: "ECDSA",
	                hash: { name: "SHA-256" } // can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
	            };
	            return ao;
	        }
	    }, {
	        key: RSA,
	        get: function get() {
	            var ao = {};
	            ao.generate = {
	                name: "RSASSA-PKCS1-v1_5",
	                modulusLength: 2048, // can be 1024, 2048, or 4096
	                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
	                hash: { name: "SHA-256" } // can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
	            };
	            ao.import = ao.sign = ao.verify = {
	                name: "RSASSA-PKCS1-v1_5",
	                hash: { name: "SHA-256" } // can be "SHA-1", "SHA-256", "SHA-384", or "SHA-512"
	            };
	            return ao;
	        }
	    }]);

	    return CryptoBrowser;
	}();

	exports.default = CryptoBrowser;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _KeyStoreCryptoEngine2 = __webpack_require__(17);

	var _KeyStoreCryptoEngine3 = _interopRequireDefault(_KeyStoreCryptoEngine2);

	var _BrowserKeyStore = __webpack_require__(18);

	var _BrowserKeyStore2 = _interopRequireDefault(_BrowserKeyStore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Crypto engine for the browser, it handles signatures, verifications,
	 * and keys are stored in IndexedDB using the following schema
	 *
	 * KEY: memberId (e.g. 'board_cols:12345:678')
	 * VALUE (JS object):
	 * {
	 *      LOW: {
	 *          id: 456,
	 *          algorithm: ECDSA,
	 *          level: LOW,
	 *          publicKey: key data in Uint8Array format
	 *          privateKey: non-extractable object
	 *      },
	 *      STANDARD: {...},
	 *      PRIVILEGED: {...},
	 * }
	 *
	 * Furthermore, activeMemberId is stored in localStorage
	 */
	var globalKeyStore = new _BrowserKeyStore2.default();

	var BrowserCryptoEngine = function (_KeyStoreCryptoEngine) {
	    _inherits(BrowserCryptoEngine, _KeyStoreCryptoEngine);

	    /**
	     * Constructs the engine, using an existing member/keys if it is in localStorage
	     *
	     * @param {string} memberId - memberId of the member we want to create the engine for
	     */
	    function BrowserCryptoEngine(memberId) {
	        _classCallCheck(this, BrowserCryptoEngine);

	        return _possibleConstructorReturn(this, (BrowserCryptoEngine.__proto__ || Object.getPrototypeOf(BrowserCryptoEngine)).call(this, memberId, globalKeyStore));
	    }

	    _createClass(BrowserCryptoEngine, null, [{
	        key: 'getActiveMemberId',
	        value: function getActiveMemberId() {
	            return _BrowserKeyStore2.default.getActiveMemberId();
	        }
	    }, {
	        key: 'setActiveMemberId',
	        value: function setActiveMemberId(memberId) {
	            _BrowserKeyStore2.default.setActiveMemberId(memberId);
	        }
	    }, {
	        key: 'clearAllKeys',
	        value: function clearAllKeys() {
	            return regeneratorRuntime.async(function clearAllKeys$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return regeneratorRuntime.awrap(globalKeyStore.clearAllKeys());

	                        case 2:
	                            return _context.abrupt('return', _context.sent);

	                        case 3:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return BrowserCryptoEngine;
	}(_KeyStoreCryptoEngine3.default);

	exports.default = BrowserCryptoEngine;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Crypto = __webpack_require__(4);

	var _Crypto2 = _interopRequireDefault(_Crypto);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Base crypto engine that are extended by others, it handles signatures, verifications, and key storage.
	 */
	var KeyStoreCryptoEngine = function () {
	    function KeyStoreCryptoEngine(memberId, keystore) {
	        _classCallCheck(this, KeyStoreCryptoEngine);

	        if (!memberId) {
	            throw new Error('Invalid memberId');
	        }
	        if (!keystore) {
	            throw new Error('Invalid keystore');
	        }
	        this._memberId = memberId;
	        this._keystore = keystore;
	        if (memberId && keystore.constructor.setActiveMemberId) {
	            keystore.constructor.setActiveMemberId(memberId);
	        }
	    }

	    /**
	     * Generate a key pair and store it.
	     *
	     * @param {string} level - "LOW", "STANDARD", or "PRIVILEGED"
	     * @param {number} expirationMs - (optional) expiration duration of the key in milliseconds
	     * @return {Object} key
	     */


	    _createClass(KeyStoreCryptoEngine, [{
	        key: 'generateKey',
	        value: function generateKey(level, expirationMs) {
	            var keyPair, stored;
	            return regeneratorRuntime.async(function generateKey$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return regeneratorRuntime.awrap(_Crypto2.default.generateKeys(level, expirationMs));

	                        case 2:
	                            keyPair = _context.sent;
	                            _context.next = 5;
	                            return regeneratorRuntime.awrap(this._keystore.put(this._memberId, keyPair));

	                        case 5:
	                            stored = _context.sent;

	                            if (stored && stored.privateKey) {
	                                delete stored.privateKey;
	                            }
	                            return _context.abrupt('return', stored);

	                        case 8:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Create a signer. Assumes we previously generated the relevant key.
	         *
	         * @param {string} level - privilege level "LOW", "STANDARD", "PRIVILEGED"
	         * @return {Object} signer object that implements sign, signJson, and getKeyId
	         */

	    }, {
	        key: 'createSigner',
	        value: function createSigner(level) {
	            var keyPair;
	            return regeneratorRuntime.async(function createSigner$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return regeneratorRuntime.awrap(this._keystore.getByLevel(this._memberId, level));

	                        case 2:
	                            keyPair = _context2.sent;
	                            return _context2.abrupt('return', _Crypto2.default.createSignerFromKeypair(keyPair));

	                        case 4:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Create a verifier. Assumes we have the key with the passed ID.
	         *
	         * @param {string} keyId - ID of key to use
	         * @return {Object} verifier object that implements verify and verifyJson
	         */

	    }, {
	        key: 'createVerifier',
	        value: function createVerifier(keyId) {
	            var keyPair;
	            return regeneratorRuntime.async(function createVerifier$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            _context3.next = 2;
	                            return regeneratorRuntime.awrap(this._keystore.getById(this._memberId, keyId));

	                        case 2:
	                            keyPair = _context3.sent;
	                            return _context3.abrupt('return', _Crypto2.default.createVerifierFromKeypair(keyPair));

	                        case 4:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return KeyStoreCryptoEngine;
	}();

	exports.default = KeyStoreCryptoEngine;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MEMBER_KEY_DB = 'member_key';
	var MEMBER_KEY_DB_VERSION = 1;
	var MEMBER_KEY_STORE = 'member_keys';

	var READ_ONLY = 'readonly';
	var READ_WRITE = 'readwrite';

	var BrowserKeyStore = function () {
	    function BrowserKeyStore() {
	        _classCallCheck(this, BrowserKeyStore);
	    }

	    _createClass(BrowserKeyStore, [{
	        key: 'put',


	        /**
	         * Store a member's key pair.
	         *
	         * @param {string} memberId - ID of member
	         * @param {Object} keyPair - key pair to store
	         * @return {Promise} promise that resolves into the key pair that was passed in
	         */
	        value: function put(memberId, keyPair) {
	            var store;
	            return regeneratorRuntime.async(function put$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (memberId) {
	                                _context.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (keyPair) {
	                                _context.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know what key to put");

	                        case 4:
	                            if (keyPair.level) {
	                                _context.next = 6;
	                                break;
	                            }

	                            throw new Error("Don't know what level to put key");

	                        case 6:
	                            if (false) {
	                                _context.next = 8;
	                                break;
	                            }

	                            throw new Error("Browser Only");

	                        case 8:
	                            if (!(keyPair.expiresAtMs < Date.now())) {
	                                _context.next = 10;
	                                break;
	                            }

	                            throw new Error('Key ' + keyPair.id + ' has expired');

	                        case 10:
	                            _context.next = 12;
	                            return regeneratorRuntime.awrap(BrowserKeyStore._getObjectStore(MEMBER_KEY_STORE, READ_WRITE));

	                        case 12:
	                            store = _context.sent;
	                            return _context.abrupt('return', new Promise(function (resolve, reject) {
	                                var getReq = store.get(memberId);
	                                getReq.onsuccess = function () {
	                                    var member = getReq.result || {};
	                                    var putReq = store.put(Object.assign(member, _defineProperty({}, keyPair.level, keyPair)), memberId);
	                                    putReq.onsuccess = function () {
	                                        BrowserKeyStore.setActiveMemberId(memberId);
	                                        resolve(keyPair);
	                                    };
	                                    putReq.onerror = function () {
	                                        return reject(new Error('Error saving member to database: ' + putReq.error));
	                                    };
	                                };
	                                getReq.onerror = function () {
	                                    return reject(new Error('Error getting member from database: ' + getReq.error));
	                                };
	                            }));

	                        case 14:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Look up a key by memberId and level.
	         *
	         * @param {string} memberId - ID of member
	         * @param {string} level - "LOW", "STANDARD", or "PRIVILEGED"
	         * @return {Promise} promise that resolves into the retrieved key pair
	         */

	    }, {
	        key: 'getByLevel',
	        value: function getByLevel(memberId, level) {
	            var store;
	            return regeneratorRuntime.async(function getByLevel$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            if (memberId) {
	                                _context2.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (level) {
	                                _context2.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know what key level to get");

	                        case 4:
	                            if (false) {
	                                _context2.next = 6;
	                                break;
	                            }

	                            throw new Error("Browser Only");

	                        case 6:
	                            _context2.next = 8;
	                            return regeneratorRuntime.awrap(BrowserKeyStore._getObjectStore(MEMBER_KEY_STORE));

	                        case 8:
	                            store = _context2.sent;
	                            return _context2.abrupt('return', new Promise(function (resolve, reject) {
	                                var getReq = store.get(memberId);
	                                getReq.onsuccess = function () {
	                                    var member = getReq.result;
	                                    if (!member) {
	                                        return reject(new Error('Member with id ' + memberId + ' not found'));
	                                    }
	                                    if (!member[level]) {
	                                        return reject(new Error('No key with level ' + level + ' found'));
	                                    }
	                                    if (member[level].expiresAtMs < Date.now()) {
	                                        return reject(new Error('Key with level ' + level + ' has expired'));
	                                    }
	                                    BrowserKeyStore.setActiveMemberId(memberId);
	                                    resolve(getReq.result[level]);
	                                };
	                                getReq.onerror = function () {
	                                    return reject(new Error('Error getting member from database: ' + getReq.error));
	                                };
	                            }));

	                        case 10:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Look up a key by memberId and keyId.
	         *
	         * @param {string} memberId - ID of member
	         * @param {string} keyId - key ID
	         * @return {Promise} promise that resolves into the retrieved key pair
	         */

	    }, {
	        key: 'getById',
	        value: function getById(memberId, keyId) {
	            var store;
	            return regeneratorRuntime.async(function getById$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            if (memberId) {
	                                _context3.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (keyId) {
	                                _context3.next = 4;
	                                break;
	                            }

	                            throw new Error('Don\'t know id of key to get');

	                        case 4:
	                            if (false) {
	                                _context3.next = 6;
	                                break;
	                            }

	                            throw new Error("Browser Only");

	                        case 6:
	                            _context3.next = 8;
	                            return regeneratorRuntime.awrap(BrowserKeyStore._getObjectStore(MEMBER_KEY_STORE));

	                        case 8:
	                            store = _context3.sent;
	                            return _context3.abrupt('return', new Promise(function (resolve, reject) {
	                                var getReq = store.get(memberId);
	                                getReq.onsuccess = function () {
	                                    var member = getReq.result;
	                                    if (!member) {
	                                        return reject(new Error('member ' + memberId + ' not found'));
	                                    }
	                                    Object.values(member).forEach(function (keyPair) {
	                                        if (keyPair.id === keyId) {
	                                            if (keyPair.expiresAtMs < Date.now()) {
	                                                reject(new Error('Key with id ' + keyPair.id + ' has expired'));
	                                            }
	                                            BrowserKeyStore.setActiveMemberId(memberId);
	                                            resolve(keyPair);
	                                        }
	                                    });
	                                    reject(new Error('No key with id ' + keyId + ' found'));
	                                };
	                                getReq.onerror = function () {
	                                    return reject(new Error('Error getting member from database: ' + getReq.error));
	                                };
	                            }));

	                        case 10:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Return list of member's keys.
	         *
	         * @param {string} memberId - ID of member
	         * @return {Promise} promise that resolves into the retrieved list of key pairs
	         */

	    }, {
	        key: 'listKeys',
	        value: function listKeys(memberId) {
	            var store;
	            return regeneratorRuntime.async(function listKeys$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (memberId) {
	                                _context4.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (false) {
	                                _context4.next = 4;
	                                break;
	                            }

	                            throw new Error("Browser Only");

	                        case 4:
	                            _context4.next = 6;
	                            return regeneratorRuntime.awrap(BrowserKeyStore._getObjectStore(MEMBER_KEY_STORE));

	                        case 6:
	                            store = _context4.sent;
	                            return _context4.abrupt('return', new Promise(function (resolve, reject) {
	                                var getReq = store.get(memberId);
	                                getReq.onsuccess = function () {
	                                    var member = getReq.result;
	                                    if (!member) {
	                                        return reject(new Error('member ' + memberId + ' not found'));
	                                    }
	                                    BrowserKeyStore.setActiveMemberId(memberId);
	                                    resolve(Object.values(member).filter(function (keyPair) {
	                                        return !(keyPair.expiresAtMs < Date.now());
	                                    }));
	                                };
	                                getReq.onerror = function () {
	                                    return reject(new Error('Error getting member from database: ' + getReq.error));
	                                };
	                            }));

	                        case 8:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Clears all keys in object store
	         *
	         * @return {Promise<any>} promise that resolves when all keys have been cleared
	         */

	    }, {
	        key: 'clearAllKeys',
	        value: function clearAllKeys() {
	            var store;
	            return regeneratorRuntime.async(function clearAllKeys$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.next = 2;
	                            return regeneratorRuntime.awrap(BrowserKeyStore._getObjectStore(MEMBER_KEY_STORE, READ_WRITE));

	                        case 2:
	                            store = _context5.sent;
	                            return _context5.abrupt('return', new Promise(function (resolve, reject) {
	                                var clearReq = store.clear();
	                                clearReq.onsuccess = function () {
	                                    return resolve();
	                                };
	                                clearReq.onerror = function () {
	                                    return reject(new Error('Error clearing the database: ' + clearReq.error));
	                                };
	                            }));

	                        case 4:
	                        case 'end':
	                            return _context5.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Opens an instance of IndexedDB
	         *
	         * @param {string} dbName - name of db
	         * @param {string} dbVersion - version of db
	         * @return {Promise<IDBDatabase>} promise that resolves into the database object
	         * @private
	         */

	    }], [{
	        key: 'setActiveMemberId',

	        /**
	         * Keep track of the ID of the most recently active member.
	         *
	         * @param {string} memberId - ID of member
	         */
	        value: function setActiveMemberId(memberId) {
	            localStorage.activeMemberId = memberId;
	        }

	        /**
	         * Get the ID of the most recently active member.
	         *
	         * @return {string} ID of member
	         */

	    }, {
	        key: 'getActiveMemberId',
	        value: function getActiveMemberId() {
	            var memberId = localStorage.activeMemberId;
	            if (!memberId) {
	                throw new Error('No active memberId on this browser');
	            }
	            return memberId;
	        }
	    }, {
	        key: '_openDb',
	        value: function _openDb(dbName, dbVersion) {
	            return regeneratorRuntime.async(function _openDb$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	                            return _context6.abrupt('return', new Promise(function (resolve, reject) {
	                                if (!indexedDB) reject(new Error('Your browser does not support IndexedDB'));
	                                var openReq = indexedDB.open(dbName, dbVersion);
	                                openReq.onsuccess = function () {
	                                    resolve(openReq.result);
	                                };
	                                openReq.onerror = function () {
	                                    return reject(new Error('Error opening database: ' + openReq.error));
	                                };
	                                openReq.onupgradeneeded = function (e) {
	                                    var db = e.target.result;
	                                    db.createObjectStore(MEMBER_KEY_STORE);
	                                };
	                            }));

	                        case 1:
	                        case 'end':
	                            return _context6.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Retrieves an object store from the db
	         *
	         * @param {string} storeName - name of object store
	         * @param {string} mode - readonly, readwrite, or readwriteflush, defaults to readonly
	         * @return {Promise<IDBObjectStore>} promise that resolves into the store object
	         * @private
	         */

	    }, {
	        key: '_getObjectStore',
	        value: function _getObjectStore(storeName) {
	            var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : READ_ONLY;
	            var db, txn;
	            return regeneratorRuntime.async(function _getObjectStore$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            _context7.next = 2;
	                            return regeneratorRuntime.awrap(BrowserKeyStore._openDb(MEMBER_KEY_DB, MEMBER_KEY_DB_VERSION));

	                        case 2:
	                            db = _context7.sent;
	                            txn = db.transaction(storeName, mode);

	                            txn.oncomplete = function () {
	                                return db.close();
	                            };
	                            txn.onerror = function () {
	                                throw new Error('Error opening transaction: ' + txn.error);
	                            };
	                            return _context7.abrupt('return', txn.objectStore(storeName));

	                        case 7:
	                        case 'end':
	                            return _context7.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return BrowserKeyStore;
	}();

	exports.default = BrowserKeyStore;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _KeyStoreCryptoEngine2 = __webpack_require__(17);

	var _KeyStoreCryptoEngine3 = _interopRequireDefault(_KeyStoreCryptoEngine2);

	var _MemoryKeyStore = __webpack_require__(20);

	var _MemoryKeyStore2 = _interopRequireDefault(_MemoryKeyStore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * MemoryCryptoEngine: Implements the CryptoEngine interface.
	 *
	 * Crypto engine to handle signatures, verifications, and key storage, in memory. Handles storage
	 * for multiple members at once, and uses the following schema:
	 *
	 * {
	 *   "ACTIVE": "board_cols:12345:678", // member ID of most-recently active member
	 *   "board_cols:12345:678": { // a member's keys:
	 *     "PRIVILEGED": {
	 *          id: "456", // key ID
	 *          algorithm: ED25519,
	 *          level: PRIVILEGED,
	 *          publicKey: Buffer(...), // public key data
	 *          privateKey: Buffer(...), // secret key data
	 *      },
	 *     "LOW": {...},
	 *     "STANDARD": {...},
	 *   },
	 *   "board_cols:91011:12d": {...} // other member's keys...
	 * }
	 *
	 */

	var globalKeyStore = new _MemoryKeyStore2.default();

	var MemoryCryptoEngine = function (_KeyStoreCryptoEngine) {
	    _inherits(MemoryCryptoEngine, _KeyStoreCryptoEngine);

	    function MemoryCryptoEngine(memberId) {
	        _classCallCheck(this, MemoryCryptoEngine);

	        return _possibleConstructorReturn(this, (MemoryCryptoEngine.__proto__ || Object.getPrototypeOf(MemoryCryptoEngine)).call(this, memberId, globalKeyStore));
	    }

	    /**
	     * Gets the currently active memberId.
	     * This allows login without caching memberId somewhere
	     *
	     * @return {string} memberId - active memberId
	     */


	    _createClass(MemoryCryptoEngine, null, [{
	        key: 'getActiveMemberId',
	        value: function getActiveMemberId() {
	            var memberId = _MemoryKeyStore2.default.getActiveMemberId();
	            if (!memberId) {
	                throw new Error('No active memberId on this browser');
	            }
	            return memberId;
	        }
	    }]);

	    return MemoryCryptoEngine;
	}(_KeyStoreCryptoEngine3.default);

	exports.default = MemoryCryptoEngine;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var globalStorage = {};

	var MemoryKeyStore = function () {
	    function MemoryKeyStore() {
	        _classCallCheck(this, MemoryKeyStore);
	    }

	    _createClass(MemoryKeyStore, [{
	        key: "put",


	        /**
	         * Store a member's key pair.
	         *
	         * @param {string} memberId - ID of member
	         * @param {Object} keyPair - key pair to store
	         * @return {Object} the stored key pair
	         */
	        value: function put(memberId, keyPair) {
	            return regeneratorRuntime.async(function put$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (memberId) {
	                                _context.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (keyPair) {
	                                _context.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know what key to put");

	                        case 4:
	                            if (keyPair.level) {
	                                _context.next = 6;
	                                break;
	                            }

	                            throw new Error("Invalid key structure: has no privilege level");

	                        case 6:
	                            if (!(keyPair.expiresAtMs < Date.now())) {
	                                _context.next = 8;
	                                break;
	                            }

	                            throw new Error("Key " + keyPair.id + " has expired");

	                        case 8:
	                            if (!globalStorage[memberId]) {
	                                globalStorage[memberId] = {};
	                            }
	                            globalStorage[memberId][keyPair.level] = clone(keyPair);
	                            globalStorage.ACTIVE = memberId;
	                            return _context.abrupt("return", clone(globalStorage[memberId][keyPair.level]));

	                        case 12:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Look up a key by memberId and level.
	         *
	         * @param {string} memberId - ID of member
	         * @param {string} level - "LOW", "STANDARD", or "PRIVILEGED"
	         * @return {Object} key pair
	         */

	    }, {
	        key: "getByLevel",
	        value: function getByLevel(memberId, level) {
	            return regeneratorRuntime.async(function getByLevel$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            if (memberId) {
	                                _context2.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (level) {
	                                _context2.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know what key level to get");

	                        case 4:
	                            if (globalStorage[memberId]) {
	                                _context2.next = 6;
	                                break;
	                            }

	                            throw new Error("member " + memberId + " not found");

	                        case 6:
	                            if (globalStorage[memberId][level]) {
	                                _context2.next = 8;
	                                break;
	                            }

	                            throw new Error("No key with level " + level + " found");

	                        case 8:
	                            if (!(globalStorage[memberId][level].expiresAtMs < Date.now())) {
	                                _context2.next = 10;
	                                break;
	                            }

	                            throw new Error("Key with level " + level + " has expired");

	                        case 10:
	                            return _context2.abrupt("return", clone(globalStorage[memberId][level]));

	                        case 11:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Look up a key by memberId and keyId.
	         *
	         * @param {string} memberId - ID of member
	         * @param {string} keyId - key ID
	         * @return {Object} key pair
	         */

	    }, {
	        key: "getById",
	        value: function getById(memberId, keyId) {
	            var level;
	            return regeneratorRuntime.async(function getById$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            if (globalStorage[memberId]) {
	                                _context3.next = 2;
	                                break;
	                            }

	                            throw new Error("member " + memberId + " not found");

	                        case 2:
	                            if (keyId) {
	                                _context3.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know id of key to get");

	                        case 4:
	                            _context3.t0 = regeneratorRuntime.keys(globalStorage[memberId]);

	                        case 5:
	                            if ((_context3.t1 = _context3.t0()).done) {
	                                _context3.next = 14;
	                                break;
	                            }

	                            level = _context3.t1.value;

	                            if (!Object.prototype.hasOwnProperty.call(globalStorage[memberId], level)) {
	                                _context3.next = 12;
	                                break;
	                            }

	                            if (!(globalStorage[memberId][level].id === keyId)) {
	                                _context3.next = 12;
	                                break;
	                            }

	                            if (!(globalStorage[memberId][level].expiresAtMs < Date.now())) {
	                                _context3.next = 11;
	                                break;
	                            }

	                            throw new Error("Key with id " + globalStorage[memberId][level].id + " has expired");

	                        case 11:
	                            return _context3.abrupt("return", clone(globalStorage[memberId][level]));

	                        case 12:
	                            _context3.next = 5;
	                            break;

	                        case 14:
	                            throw new Error("No key with id " + keyId + " found");

	                        case 15:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Return list of member's keys.
	         *
	         * @param {string} memberId - ID of member
	         * @return {Object} list of keys
	         */

	    }, {
	        key: "listKeys",
	        value: function listKeys(memberId) {
	            return regeneratorRuntime.async(function listKeys$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (globalStorage[memberId]) {
	                                _context4.next = 2;
	                                break;
	                            }

	                            throw new Error("member " + memberId + " not found");

	                        case 2:
	                            return _context4.abrupt("return", Object.keys(globalStorage[memberId]).map(function (level) {
	                                return clone(globalStorage[memberId][level]);
	                            }).filter(function (keyPair) {
	                                return !(keyPair.expiresAtMs < Date.now());
	                            }));

	                        case 3:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Keep track of the ID of the most recently active member.
	         *
	         * @param {string} memberId - ID of member
	         */

	    }], [{
	        key: "setActiveMemberId",
	        value: function setActiveMemberId(memberId) {
	            globalStorage.ACTIVE = memberId;
	        }

	        /**
	         * Get the ID of the most recently active member.
	         *
	         * @return {string} ID of member
	         */

	    }, {
	        key: "getActiveMemberId",
	        value: function getActiveMemberId() {
	            var memberId = globalStorage.ACTIVE;
	            if (!memberId) {
	                throw new Error('No active memberId');
	            }
	            return memberId;
	        }
	    }]);

	    return MemoryKeyStore;
	}();

	/**
	 * Return a (shallow) copy of an object.
	 *
	 * If the "user" of a key pair object edits it (e.g., deleting privateKey),
	 * that shouldn't affect the "stored" key pair. Thus, we can't pass around
	 * references to stored objects. Instead, we do some object-copying.
	 *
	 * @param {Object} obj - object to copy
	 * @return {Object} copy of obj
	 */


	function clone(obj) {
	    return Object.assign({}, obj);
	}

	exports.default = MemoryKeyStore;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _MemoryKeyStore = __webpack_require__(20);

	var _MemoryKeyStore2 = _interopRequireDefault(_MemoryKeyStore);

	var _KeyStoreCryptoEngine2 = __webpack_require__(17);

	var _KeyStoreCryptoEngine3 = _interopRequireDefault(_KeyStoreCryptoEngine2);

	var _Crypto = __webpack_require__(4);

	var _Crypto2 = _interopRequireDefault(_Crypto);

	var _base64url = __webpack_require__(13);

	var _base64url2 = _interopRequireDefault(_base64url);

	var _fastSha = __webpack_require__(9);

	var _fastSha2 = _interopRequireDefault(_fastSha);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var keys = [];
	var globalKeyStore = new _MemoryKeyStore2.default();

	/**
	 * Crypto engine that handles hardcoded keys
	 */

	var ManualCryptoEngine = function (_KeyStoreCryptoEngine) {
	    _inherits(ManualCryptoEngine, _KeyStoreCryptoEngine);

	    _createClass(ManualCryptoEngine, null, [{
	        key: "setKeys",

	        /**
	         * Set the hardcoded keys used by ManualCryptoEngine
	         *
	         * @param {Array} memberKeys - keys to set
	         *
	         * Must be an array with objects of the format:
	         * {
	         *     publicKey: "123456",
	         *     privateKey: "123456",
	         *     level: "LOW" || "STANDARD" || "PRIVILEGED",
	         * }
	         */
	        value: function setKeys(memberKeys) {
	            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, keyPair;

	            return regeneratorRuntime.async(function setKeys$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(!memberKeys || !Array.isArray(memberKeys) || memberKeys.length < 1)) {
	                                _context.next = 2;
	                                break;
	                            }

	                            throw new Error('invalid keys format');

	                        case 2:
	                            keys = memberKeys;
	                            _iteratorNormalCompletion = true;
	                            _didIteratorError = false;
	                            _iteratorError = undefined;
	                            _context.prev = 6;
	                            _iterator = keys[Symbol.iterator]();

	                        case 8:
	                            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
	                                _context.next = 19;
	                                break;
	                            }

	                            keyPair = _step.value;

	                            if (!(!keyPair.publicKey || !keyPair.privateKey || !keyPair.level)) {
	                                _context.next = 12;
	                                break;
	                            }

	                            throw new Error("Invalid keyPair format");

	                        case 12:
	                            if (typeof keyPair.publicKey === 'string') {
	                                keyPair.publicKey = _Crypto2.default.bufferKey(keyPair.publicKey);
	                            }
	                            if (typeof keyPair.privateKey === 'string') {
	                                keyPair.privateKey = _Crypto2.default.bufferKey(keyPair.privateKey);
	                            }
	                            if (!keyPair.id) {
	                                keyPair.id = (0, _base64url2.default)((0, _fastSha2.default)(keyPair.publicKey)).substring(0, 16);
	                            }
	                            keyPair.algorithm = 'ED25519';

	                        case 16:
	                            _iteratorNormalCompletion = true;
	                            _context.next = 8;
	                            break;

	                        case 19:
	                            _context.next = 25;
	                            break;

	                        case 21:
	                            _context.prev = 21;
	                            _context.t0 = _context["catch"](6);
	                            _didIteratorError = true;
	                            _iteratorError = _context.t0;

	                        case 25:
	                            _context.prev = 25;
	                            _context.prev = 26;

	                            if (!_iteratorNormalCompletion && _iterator.return) {
	                                _iterator.return();
	                            }

	                        case 28:
	                            _context.prev = 28;

	                            if (!_didIteratorError) {
	                                _context.next = 31;
	                                break;
	                            }

	                            throw _iteratorError;

	                        case 31:
	                            return _context.finish(28);

	                        case 32:
	                            return _context.finish(25);

	                        case 33:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this, [[6, 21, 25, 33], [26,, 28, 32]]);
	        }
	    }]);

	    function ManualCryptoEngine(memberId) {
	        _classCallCheck(this, ManualCryptoEngine);

	        if (keys.length < 1) {
	            throw new Error('Keys must be set before constructing.');
	        }
	        return _possibleConstructorReturn(this, (ManualCryptoEngine.__proto__ || Object.getPrototypeOf(ManualCryptoEngine)).call(this, memberId, globalKeyStore));
	    }

	    /**
	     * Generate a keyPair and store it.
	     *
	     * @param {string} level - privilege level "LOW", "STANDARD", "PRIVILEGED"
	     * @return {Object} key
	     */


	    _createClass(ManualCryptoEngine, [{
	        key: "generateKey",
	        value: function generateKey(level) {
	            var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, keyPair, cloned;

	            return regeneratorRuntime.async(function generateKey$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _iteratorNormalCompletion2 = true;
	                            _didIteratorError2 = false;
	                            _iteratorError2 = undefined;
	                            _context2.prev = 3;
	                            _iterator2 = keys[Symbol.iterator]();

	                        case 5:
	                            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
	                                _context2.next = 14;
	                                break;
	                            }

	                            keyPair = _step2.value;

	                            if (!(keyPair.level === level)) {
	                                _context2.next = 11;
	                                break;
	                            }

	                            cloned = clone(keyPair);

	                            if (cloned.privateKey) {
	                                delete cloned.privateKey;
	                            }
	                            return _context2.abrupt("return", cloned);

	                        case 11:
	                            _iteratorNormalCompletion2 = true;
	                            _context2.next = 5;
	                            break;

	                        case 14:
	                            _context2.next = 20;
	                            break;

	                        case 16:
	                            _context2.prev = 16;
	                            _context2.t0 = _context2["catch"](3);
	                            _didIteratorError2 = true;
	                            _iteratorError2 = _context2.t0;

	                        case 20:
	                            _context2.prev = 20;
	                            _context2.prev = 21;

	                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                _iterator2.return();
	                            }

	                        case 23:
	                            _context2.prev = 23;

	                            if (!_didIteratorError2) {
	                                _context2.next = 26;
	                                break;
	                            }

	                            throw _iteratorError2;

	                        case 26:
	                            return _context2.finish(23);

	                        case 27:
	                            return _context2.finish(20);

	                        case 28:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this, [[3, 16, 20, 28], [21,, 23, 27]]);
	        }

	        /**
	         * Create a signer. Assumes we previously generated the relevant key.
	         *
	         * @param {string} level - privilege level "LOW", "STANDARD", "PRIVILEGED"
	         * @return {Object} signer - object that implements sign, signJson
	         */

	    }, {
	        key: "createSigner",
	        value: function createSigner(level) {
	            var keyPairs;
	            return regeneratorRuntime.async(function createSigner$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            keyPairs = keys.filter(function (k) {
	                                return k.level === level;
	                            });

	                            if (!(!keyPairs || !keyPairs.length)) {
	                                _context3.next = 3;
	                                break;
	                            }

	                            throw new Error("No key with level " + level + " found");

	                        case 3:
	                            return _context3.abrupt("return", _Crypto2.default.createSignerFromKeypair(clone(keyPairs[0])));

	                        case 4:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Create a verifier. Assumes we have the key with the passed ID.
	         *
	         * @param {string} keyId - ID of key to use
	         * @return {Object} signer - object that implements verify, verifyJson
	         */

	    }, {
	        key: "createVerifier",
	        value: function createVerifier(keyId) {
	            var keyPairs;
	            return regeneratorRuntime.async(function createVerifier$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            keyPairs = keys.filter(function (k) {
	                                return k.id === keyId;
	                            });

	                            if (!(!keyPairs || !keyPairs.length)) {
	                                _context4.next = 3;
	                                break;
	                            }

	                            throw new Error("No key with id " + keyId + " found");

	                        case 3:
	                            return _context4.abrupt("return", _Crypto2.default.createVerifierFromKeypair(clone(keyPairs[0])));

	                        case 4:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return ManualCryptoEngine;
	}(_KeyStoreCryptoEngine3.default);

	/**
	 * Return a (shallow) copy of an object.
	 *
	 * If the "user" of a key pair object edits it (e.g., deleting privateKey),
	 * that shouldn't affect the "stored" key pair. Thus, we can't pass around
	 * references to stored objects. Instead, we do some object-copying.
	 *
	 * @param {Object} obj - object to copy
	 * @return {Object} copy of obj
	 */


	function clone(obj) {
	    return Object.assign({}, obj);
	}

	exports.default = ManualCryptoEngine;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _KeyStoreCryptoEngine2 = __webpack_require__(17);

	var _KeyStoreCryptoEngine3 = _interopRequireDefault(_KeyStoreCryptoEngine2);

	var _UnsecuredFileKeyStore = __webpack_require__(23);

	var _UnsecuredFileKeyStore2 = _interopRequireDefault(_UnsecuredFileKeyStore);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * UnsecuredFileCryptoEngine: Implements the CryptoEngine interface.
	 *
	 * Crypto engine to handle signatures, verifications, and key storage, in a file. Uses the following
	 * schema
	 *
	 * filename: memberId
	 *
	 * file contents: {
	 *    "keys":[{
	 *        "id":"HxxJ-LKfhYVSDMgC", // key ID
	 *        "level":"LOW",
	 *        "algorithm":"ED25519",
	 *        "publicKey":"wHhFB13fbFVwXGkHPToWASQCQ3hJegQQ", // Crypto.strKey( public key )
	 *        "privateKey":"YgnDobEA0HoZvM7YXvJBR1Sd006apRbeEl6BBA" // Crypto.strKey( secret key )
	 *    }],
	 * }
	 */
	var globalKeyStore = new _UnsecuredFileKeyStore2.default();

	var dirRootSet = null;

	var UnsecuredFileCryptoEngine = function (_KeyStoreCryptoEngine) {
	    _inherits(UnsecuredFileCryptoEngine, _KeyStoreCryptoEngine);

	    _createClass(UnsecuredFileCryptoEngine, null, [{
	        key: 'setDirRoot',

	        /**
	         * Set the dir in which we'll store key-files.
	         * When an sdk user calls Token = new TokenLib('sandbox', './keys'),
	         * that calls UnsecuredFileCryptoEngine.setDirRoot('./keys')
	         *
	         * @param {string} dirRoot - path
	         */
	        value: function setDirRoot(dirRoot) {
	            _UnsecuredFileKeyStore2.default.setDirRoot(dirRoot);
	            dirRootSet = dirRoot;
	        }

	        /**
	         * Constructs the engine
	         *
	         * @param {string} memberId - memberId of the member we want to create the engine for
	         */

	    }]);

	    function UnsecuredFileCryptoEngine(memberId) {
	        _classCallCheck(this, UnsecuredFileCryptoEngine);

	        if (false) {
	            throw new Error("Not available on browser");
	        }
	        if (!memberId) {
	            throw new Error("Invalid memberId");
	        }
	        if (!dirRootSet) {
	            throw new Error("No valid directory set");
	        }

	        return _possibleConstructorReturn(this, (UnsecuredFileCryptoEngine.__proto__ || Object.getPrototypeOf(UnsecuredFileCryptoEngine)).call(this, memberId, globalKeyStore));
	    }

	    /**
	     * Get ID of "active" member. (This would make more sense in browser,
	     * where we'd use it to keep track of browser-linked member.)
	     *
	     * @return {string} member ID of active member (or throw if none such);
	     */


	    _createClass(UnsecuredFileCryptoEngine, null, [{
	        key: 'getActiveMemberId',
	        value: function getActiveMemberId() {
	            var memberId = _UnsecuredFileKeyStore2.default.getActiveMemberId();
	            if (!memberId) {
	                throw new Error('No active memberId on this browser');
	            }
	            return memberId;
	        }
	    }]);

	    return UnsecuredFileCryptoEngine;
	}(_KeyStoreCryptoEngine3.default);

	exports.default = UnsecuredFileCryptoEngine;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Crypto = __webpack_require__(4);

	var _Crypto2 = _interopRequireDefault(_Crypto);

	var _PromiseFileSystem = __webpack_require__(24);

	var _PromiseFileSystem2 = _interopRequireDefault(_PromiseFileSystem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var globals = {
	    activeMemberId: ''
	};

	var UnsecuredFileKeyStore = function () {
	    function UnsecuredFileKeyStore() {
	        _classCallCheck(this, UnsecuredFileKeyStore);
	    }

	    _createClass(UnsecuredFileKeyStore, [{
	        key: 'put',


	        /**
	         * Store a key pair.
	         *
	         * @param {string} memberId - ID of member
	         * @param {Object} keyPair - key pair
	         * @return {Object} stored key pair
	         */
	        value: function put(memberId, keyPair) {
	            var member;
	            return regeneratorRuntime.async(function put$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (memberId) {
	                                _context.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (keyPair) {
	                                _context.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know what key to put");

	                        case 4:
	                            if (keyPair.level) {
	                                _context.next = 6;
	                                break;
	                            }

	                            throw new Error("Don't know what level to put key");

	                        case 6:
	                            if (!(keyPair.expiresAtMs < Date.now())) {
	                                _context.next = 8;
	                                break;
	                            }

	                            throw new Error('Key ' + keyPair.id + ' has expired');

	                        case 8:
	                            if (true) {
	                                _context.next = 10;
	                                break;
	                            }

	                            throw new Error("Not available on browser");

	                        case 10:
	                            _context.next = 12;
	                            return regeneratorRuntime.awrap(this._loadMember(memberId));

	                        case 12:
	                            _context.t0 = _context.sent;

	                            if (_context.t0) {
	                                _context.next = 15;
	                                break;
	                            }

	                            _context.t0 = {};

	                        case 15:
	                            member = _context.t0;

	                            member[keyPair.level] = keyPair;
	                            _context.next = 19;
	                            return regeneratorRuntime.awrap(this._saveMember(memberId, member));

	                        case 19:
	                            UnsecuredFileKeyStore.setActiveMemberId(memberId);
	                            return _context.abrupt('return', keyPair);

	                        case 21:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Look up a key by memberId and level.
	         *
	         * @param {string} memberId - ID of member
	         * @param {string} level - "LOW", "STANDARD", or "PRIVILEGED"
	         * @return {Object} key pair
	         */

	    }, {
	        key: 'getByLevel',
	        value: function getByLevel(memberId, level) {
	            var member;
	            return regeneratorRuntime.async(function getByLevel$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            if (memberId) {
	                                _context2.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (level) {
	                                _context2.next = 4;
	                                break;
	                            }

	                            throw new Error("Don't know what key level to get");

	                        case 4:
	                            if (true) {
	                                _context2.next = 6;
	                                break;
	                            }

	                            throw new Error("Not available on browser");

	                        case 6:
	                            _context2.next = 8;
	                            return regeneratorRuntime.awrap(this._loadMember(memberId));

	                        case 8:
	                            member = _context2.sent;

	                            if (member) {
	                                _context2.next = 11;
	                                break;
	                            }

	                            throw new Error('Member with id ' + memberId + ' not found');

	                        case 11:
	                            if (member[level]) {
	                                _context2.next = 13;
	                                break;
	                            }

	                            throw new Error('No key with level ' + level + ' found');

	                        case 13:
	                            if (!(member[level].expiresAtMs < Date.now())) {
	                                _context2.next = 15;
	                                break;
	                            }

	                            throw new Error('Key with level ' + level + ' has expired');

	                        case 15:
	                            UnsecuredFileKeyStore.setActiveMemberId(memberId);
	                            return _context2.abrupt('return', member[level]);

	                        case 17:
	                        case 'end':
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Look up a key by memberId and keyId.
	         *
	         * @param {string} memberId - ID of member
	         * @param {string} keyId - key ID
	         * @return {Object} key pair
	         */

	    }, {
	        key: 'getById',
	        value: function getById(memberId, keyId) {
	            var member, level;
	            return regeneratorRuntime.async(function getById$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            if (memberId) {
	                                _context3.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (keyId) {
	                                _context3.next = 4;
	                                break;
	                            }

	                            throw new Error('Don\'t know id of key to get');

	                        case 4:
	                            if (true) {
	                                _context3.next = 6;
	                                break;
	                            }

	                            throw new Error("Not available on browser");

	                        case 6:
	                            _context3.next = 8;
	                            return regeneratorRuntime.awrap(this._loadMember(memberId));

	                        case 8:
	                            member = _context3.sent;

	                            if (member) {
	                                _context3.next = 11;
	                                break;
	                            }

	                            throw new Error('member ' + memberId + ' not found');

	                        case 11:
	                            _context3.t0 = regeneratorRuntime.keys(member);

	                        case 12:
	                            if ((_context3.t1 = _context3.t0()).done) {
	                                _context3.next = 22;
	                                break;
	                            }

	                            level = _context3.t1.value;

	                            if (!Object.prototype.hasOwnProperty.call(member, level)) {
	                                _context3.next = 20;
	                                break;
	                            }

	                            if (!(member[level].id === keyId)) {
	                                _context3.next = 20;
	                                break;
	                            }

	                            if (!(member[level].expiresAtMs < Date.now())) {
	                                _context3.next = 18;
	                                break;
	                            }

	                            throw new Error('Key with id ' + member[level].id + ' has expired');

	                        case 18:
	                            UnsecuredFileKeyStore.setActiveMemberId(memberId);
	                            return _context3.abrupt('return', member[level]);

	                        case 20:
	                            _context3.next = 12;
	                            break;

	                        case 22:
	                            throw new Error('No key with id ' + keyId + ' found');

	                        case 23:
	                        case 'end':
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Return list of member's keys.
	         *
	         * @param {string} memberId - ID of member
	         * @return {Object} list of keys
	         */

	    }, {
	        key: 'listKeys',
	        value: function listKeys(memberId) {
	            var member, list, level;
	            return regeneratorRuntime.async(function listKeys$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            if (memberId) {
	                                _context4.next = 2;
	                                break;
	                            }

	                            throw new Error("Invalid memberId");

	                        case 2:
	                            if (true) {
	                                _context4.next = 4;
	                                break;
	                            }

	                            throw new Error("Not available on browser");

	                        case 4:
	                            _context4.next = 6;
	                            return regeneratorRuntime.awrap(this._loadMember(memberId));

	                        case 6:
	                            member = _context4.sent;

	                            if (member) {
	                                _context4.next = 10;
	                                break;
	                            }

	                            if (member) {
	                                _context4.next = 10;
	                                break;
	                            }

	                            throw new Error('member ' + memberId + ' not found');

	                        case 10:
	                            UnsecuredFileKeyStore.setActiveMemberId(memberId);
	                            list = [];

	                            for (level in member) {
	                                if (member.hasOwnProperty(level) && !(member[level].expiresAtMs < Date.now())) {
	                                    list.push(member[level]);
	                                }
	                            }
	                            return _context4.abrupt('return', list);

	                        case 14:
	                        case 'end':
	                            return _context4.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Keep track of the ID of the most recently active member.
	         *
	         * @param {string} memberId - ID of member
	         */

	    }, {
	        key: '_saveMember',


	        /**
	         * Save a member's keys.
	         *
	         * @param {string} memberId - member Id
	         * @param {Object} member - obj dict of keys { "LOW": {...}, "STANDARD": {...}, ... }
	         */
	        value: function _saveMember(memberId, member) {
	            var strKeys, level, keyCopy;
	            return regeneratorRuntime.async(function _saveMember$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            // instead of { LOW: {...}, ... } we want [ {...}, ... ]
	                            // convert keys from buffer -> string
	                            strKeys = [];

	                            for (level in member) {
	                                if (member.hasOwnProperty(level)) {
	                                    keyCopy = Object.assign({}, member[level]);

	                                    if (keyCopy.publicKey) {
	                                        keyCopy.publicKey = _Crypto2.default.strKey(keyCopy.publicKey);
	                                    }
	                                    if (keyCopy.privateKey) {
	                                        keyCopy.privateKey = _Crypto2.default.strKey(keyCopy.privateKey);
	                                    }
	                                    strKeys.push(keyCopy);
	                                }
	                            }
	                            _context5.next = 4;
	                            return regeneratorRuntime.awrap(_PromiseFileSystem2.default.writeFile(memberId.split(':').join('_'), JSON.stringify({ keys: strKeys })));

	                        case 4:
	                        case 'end':
	                            return _context5.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Load a member's keys.
	         *
	         * @param {string} memberId - ID of member
	         * @return {Object} object dict level : key {"LOW": {...}, "STANDARD": {...}, ...}
	         */

	    }, {
	        key: '_loadMember',
	        value: function _loadMember(memberId) {
	            var data, keyList, member, i, key;
	            return regeneratorRuntime.async(function _loadMember$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	                            data = void 0;
	                            _context6.prev = 1;
	                            _context6.next = 4;
	                            return regeneratorRuntime.awrap(_PromiseFileSystem2.default.readFile(memberId.split(':').join('_')));

	                        case 4:
	                            data = _context6.sent;
	                            _context6.next = 10;
	                            break;

	                        case 7:
	                            _context6.prev = 7;
	                            _context6.t0 = _context6['catch'](1);

	                            data = '{"keys":[]}';

	                        case 10:
	                            keyList = JSON.parse(data).keys || [];
	                            member = {};

	                            for (i = 0; i < keyList.length; i++) {
	                                key = keyList[i];

	                                if (key.publicKey) {
	                                    key.publicKey = _Crypto2.default.bufferKey(key.publicKey);
	                                }
	                                if (key.privateKey) {
	                                    key.privateKey = _Crypto2.default.bufferKey(key.privateKey);
	                                }
	                                member[key.level] = key;
	                            }
	                            return _context6.abrupt('return', member);

	                        case 14:
	                        case 'end':
	                            return _context6.stop();
	                    }
	                }
	            }, null, this, [[1, 7]]);
	        }
	    }], [{
	        key: 'setDirRoot',
	        value: function setDirRoot(dirRoot) {
	            _PromiseFileSystem2.default.dirRoot = dirRoot;
	        }
	    }, {
	        key: 'setActiveMemberId',
	        value: function setActiveMemberId(memberId) {
	            globals.activeMemberId = memberId;
	        }

	        /**
	         * Get the ID of the most recently active member.
	         *
	         * @return {string} ID of member
	         */

	    }, {
	        key: 'getActiveMemberId',
	        value: function getActiveMemberId() {
	            var memberId = globals.activeMemberId;
	            if (!memberId) {
	                throw new Error('No active memberId on this browser');
	            }
	            return memberId;
	        }
	    }]);

	    return UnsecuredFileKeyStore;
	}();

	exports.default = UnsecuredFileKeyStore;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var fs = void 0;
	var path = void 0;

	if (true) {
	    fs = __webpack_require__(25);
	    path = __webpack_require__(26);
	}

	var PromiseFileSystem = function () {
	    function PromiseFileSystem() {
	        _classCallCheck(this, PromiseFileSystem);
	    }

	    _createClass(PromiseFileSystem, null, [{
	        key: 'readFile',


	        /**
	         * Reads a file from the filesystem (from the given directory)
	         *
	         * @param {string} filename - file to read
	         * @return {Promise} promise - with data
	         */
	        value: function readFile(filename) {
	            if (false) return Promise.reject('Not available on browser');

	            return new Promise(function (resolve, reject) {
	                fs.readFile(PromiseFileSystem._getFullFilename(filename), PromiseFileSystem._options, function (err, buffer) {
	                    if (err) {
	                        reject(err);
	                    } else {
	                        resolve(buffer);
	                    }
	                });
	            });
	        }
	    }, {
	        key: 'writeFile',
	        value: function writeFile(filename, data) {
	            if (false) return Promise.reject('Not available on browser');

	            return new Promise(function (resolve, reject) {
	                PromiseFileSystem._ensureExists(PromiseFileSystem.dirRoot, function (err) {
	                    if (err) {
	                        reject(err);
	                    }
	                    fs.writeFile(PromiseFileSystem._getFullFilename(filename), data, PromiseFileSystem._options, function (err) {
	                        if (err) {
	                            reject(err);
	                        } else {
	                            resolve();
	                        }
	                    });
	                });
	            });
	        }
	    }, {
	        key: '_ensureExists',
	        value: function _ensureExists(path, cb) {
	            if (false) return Promise.reject('Not available on browser');

	            fs.mkdir(path, function (err) {
	                if (err) {
	                    if (err.code === 'EEXIST') cb(null); // ignore folder already exists
	                    else cb(err); // something else went wrong
	                } else cb(null); // successfully created folder
	            });
	        }
	    }, {
	        key: '_getFullFilename',
	        value: function _getFullFilename(filename) {
	            if (false) return Promise.reject('Not available on browser');

	            return path.join(PromiseFileSystem.dirRoot, filename);
	        }
	    }]);

	    return PromiseFileSystem;
	}();

	PromiseFileSystem._options = { encoding: 'utf-8', mode: 384 };
	PromiseFileSystem.dirRoot = null;

	exports.default = PromiseFileSystem;

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = require("fs");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = require("path");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _AuthHttpClient = __webpack_require__(28);

	var _AuthHttpClient2 = _interopRequireDefault(_AuthHttpClient);

	var _HttpClient = __webpack_require__(44);

	var _HttpClient2 = _interopRequireDefault(_HttpClient);

	var _TransferTokenBuilder = __webpack_require__(45);

	var _TransferTokenBuilder2 = _interopRequireDefault(_TransferTokenBuilder);

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	var _AccessTokenBuilder = __webpack_require__(46);

	var _AccessTokenBuilder2 = _interopRequireDefault(_AccessTokenBuilder);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Member object. Allows member-wide actions. Some calls return a promise, and some return
	 * objects
	 *
	 */
	var Member = function () {

	    /**
	     * Represents a Member
	     *
	     * @constructor
	     * @param {string} env - The environment to use for this member
	     * @param {string} memberId - The id of this memberId
	     * @param {Object} cryptoEngine - the cryptoEngine to use for signing and key storage
	     * @param {string} developerKey - the developer key
	     * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
	     * @param {bool} loggingEnabled - enable HTTP error logging if true
	     * call error. For example: SDK version mismatch
	     * @param {string} customSdkUrl - set to override the default sdk url
	     */
	    function Member(env, memberId, cryptoEngine, developerKey, globalRpcErrorCallback, loggingEnabled, customSdkUrl) {
	        _classCallCheck(this, Member);

	        this._id = memberId;
	        this._client = new _AuthHttpClient2.default(env, memberId, cryptoEngine, developerKey, globalRpcErrorCallback, loggingEnabled, customSdkUrl);
	        this._unauthenticatedClient = new _HttpClient2.default(env, developerKey, globalRpcErrorCallback, loggingEnabled, customSdkUrl);
	    }

	    /**
	     * Gets the memberId
	     *
	     * @return {string} memberId
	     */


	    _createClass(Member, [{
	        key: "memberId",
	        value: function memberId() {
	            return this._id;
	        }

	        /**
	         * Gets all of the member's aliases
	         *
	         * @return {Promise} aliases - member's aliases
	         */

	    }, {
	        key: "aliases",
	        value: function aliases() {
	            var _this = this;

	            return _Util2.default.callAsync(this.aliases, function _callee() {
	                var res;
	                return regeneratorRuntime.async(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                _context.next = 2;
	                                return regeneratorRuntime.awrap(_this._client.getAliases());

	                            case 2:
	                                res = _context.sent;
	                                return _context.abrupt("return", res.data.aliases);

	                            case 4:
	                            case "end":
	                                return _context.stop();
	                        }
	                    }
	                }, null, _this);
	            });
	        }

	        /**
	         * Gets the member's first alias
	         *
	         * @return {Promise} alias - member's alias
	         */

	    }, {
	        key: "firstAlias",
	        value: function firstAlias() {
	            var _this2 = this;

	            return _Util2.default.callAsync(this.firstAlias, function _callee2() {
	                var res;
	                return regeneratorRuntime.async(function _callee2$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                _context2.next = 2;
	                                return regeneratorRuntime.awrap(_this2._client.getAliases());

	                            case 2:
	                                res = _context2.sent;
	                                return _context2.abrupt("return", res.data.aliases[0]);

	                            case 4:
	                            case "end":
	                                return _context2.stop();
	                        }
	                    }
	                }, null, _this2);
	            });
	        }

	        /**
	         * Gets the member's public keys
	         *
	         * @return {Promise} keys - keys objects
	         */

	    }, {
	        key: "keys",
	        value: function keys() {
	            var _this3 = this;

	            return _Util2.default.callAsync(this.keys, function _callee3() {
	                var member;
	                return regeneratorRuntime.async(function _callee3$(_context3) {
	                    while (1) {
	                        switch (_context3.prev = _context3.next) {
	                            case 0:
	                                _context3.next = 2;
	                                return regeneratorRuntime.awrap(_this3._getMember());

	                            case 2:
	                                member = _context3.sent;
	                                return _context3.abrupt("return", member.keys);

	                            case 4:
	                            case "end":
	                                return _context3.stop();
	                        }
	                    }
	                }, null, _this3);
	            });
	        }

	        /**
	         * Sets the access token id to be used with this client.
	         *
	         * @param {string} accessTokenId - the access token id
	         */

	    }, {
	        key: "useAccessToken",
	        value: function useAccessToken(accessTokenId) {
	            this._client.useAccessToken(accessTokenId);
	        }

	        /**
	         * Clears the access token id used with this client.
	         */

	    }, {
	        key: "clearAccessToken",
	        value: function clearAccessToken() {
	            this._client.clearAccessToken();
	        }

	        /**
	         * Sets the customer initiated request flag to true.
	         */

	    }, {
	        key: "setCustomerInitiated",
	        value: function setCustomerInitiated() {
	            this._client.setCustomerInitiated();
	        }

	        /**
	         * Approves a new key for this member
	         *
	         * @param {Object} key - key to add
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "approveKey",
	        value: function approveKey(key) {
	            var _this4 = this;

	            return _Util2.default.callAsync(this.approveKey, function _callee4() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee4$(_context4) {
	                    while (1) {
	                        switch (_context4.prev = _context4.next) {
	                            case 0:
	                                _context4.next = 2;
	                                return regeneratorRuntime.awrap(_this4._getPreviousHash());

	                            case 2:
	                                prevHash = _context4.sent;
	                                _context4.next = 5;
	                                return regeneratorRuntime.awrap(_this4._client.approveKey(prevHash, key));

	                            case 5:
	                            case "end":
	                                return _context4.stop();
	                        }
	                    }
	                }, null, _this4);
	            });
	        }

	        /**
	         * Approves new keys for this member
	         *
	         * @param {Array} keys - keys to add
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "approveKeys",
	        value: function approveKeys(keys) {
	            var _this5 = this;

	            return _Util2.default.callAsync(this.approveKeys, function _callee5() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee5$(_context5) {
	                    while (1) {
	                        switch (_context5.prev = _context5.next) {
	                            case 0:
	                                _context5.next = 2;
	                                return regeneratorRuntime.awrap(_this5._getPreviousHash());

	                            case 2:
	                                prevHash = _context5.sent;
	                                _context5.next = 5;
	                                return regeneratorRuntime.awrap(_this5._client.approveKeys(prevHash, keys));

	                            case 5:
	                            case "end":
	                                return _context5.stop();
	                        }
	                    }
	                }, null, _this5);
	            });
	        }

	        /**
	         * Removes a key from this member
	         *
	         * @param {string} keyId - keyId to remove. Note, keyId is the hash of the pk
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "removeKey",
	        value: function removeKey(keyId) {
	            var _this6 = this;

	            return _Util2.default.callAsync(this.removeKey, function _callee6() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee6$(_context6) {
	                    while (1) {
	                        switch (_context6.prev = _context6.next) {
	                            case 0:
	                                _context6.next = 2;
	                                return regeneratorRuntime.awrap(_this6._getPreviousHash());

	                            case 2:
	                                prevHash = _context6.sent;
	                                _context6.next = 5;
	                                return regeneratorRuntime.awrap(_this6._client.removeKey(prevHash, keyId));

	                            case 5:
	                            case "end":
	                                return _context6.stop();
	                        }
	                    }
	                }, null, _this6);
	            });
	        }

	        /**
	         * Removes keys from this member
	         *
	         * @param {Array} keyIds - keyIds to remove. Note, keyId is the hash of the pk
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "removeKeys",
	        value: function removeKeys(keyIds) {
	            var _this7 = this;

	            return _Util2.default.callAsync(this.removeKeys, function _callee7() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee7$(_context7) {
	                    while (1) {
	                        switch (_context7.prev = _context7.next) {
	                            case 0:
	                                _context7.next = 2;
	                                return regeneratorRuntime.awrap(_this7._getPreviousHash());

	                            case 2:
	                                prevHash = _context7.sent;
	                                _context7.next = 5;
	                                return regeneratorRuntime.awrap(_this7._client.removeKeys(prevHash, keyIds));

	                            case 5:
	                            case "end":
	                                return _context7.stop();
	                        }
	                    }
	                }, null, _this7);
	            });
	        }

	        /**
	         * Adds an alias to this member
	         *
	         * @param {Object} alias - alias to add
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "addAlias",
	        value: function addAlias(alias, realm) {
	            var _this8 = this;

	            return _Util2.default.callAsync(this.addAlias, function _callee8() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee8$(_context8) {
	                    while (1) {
	                        switch (_context8.prev = _context8.next) {
	                            case 0:
	                                _context8.next = 2;
	                                return regeneratorRuntime.awrap(_this8._getPreviousHash());

	                            case 2:
	                                prevHash = _context8.sent;
	                                _context8.next = 5;
	                                return regeneratorRuntime.awrap(_this8._client.addAlias(prevHash, alias, realm));

	                            case 5:
	                            case "end":
	                                return _context8.stop();
	                        }
	                    }
	                }, null, _this8);
	            });
	        }

	        /**
	         * Adds aliases to this member
	         *
	         * @param {Array} aliases - aliases to add
	         * @param {string} realm - (optional) realm of the aliases
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "addAliases",
	        value: function addAliases(aliases, realm) {
	            var _this9 = this;

	            return _Util2.default.callAsync(this.addAliases, function _callee9() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee9$(_context9) {
	                    while (1) {
	                        switch (_context9.prev = _context9.next) {
	                            case 0:
	                                _context9.next = 2;
	                                return regeneratorRuntime.awrap(_this9._getPreviousHash());

	                            case 2:
	                                prevHash = _context9.sent;
	                                _context9.next = 5;
	                                return regeneratorRuntime.awrap(_this9._client.addAliases(prevHash, aliases, realm));

	                            case 5:
	                            case "end":
	                                return _context9.stop();
	                        }
	                    }
	                }, null, _this9);
	            });
	        }

	        /**
	         * Removes an alias from the memberId
	         *
	         * @param {Object} alias - alias to remove
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "removeAlias",
	        value: function removeAlias(alias) {
	            var _this10 = this;

	            return _Util2.default.callAsync(this.removeAlias, function _callee10() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee10$(_context10) {
	                    while (1) {
	                        switch (_context10.prev = _context10.next) {
	                            case 0:
	                                _context10.next = 2;
	                                return regeneratorRuntime.awrap(_this10._getPreviousHash());

	                            case 2:
	                                prevHash = _context10.sent;
	                                _context10.next = 5;
	                                return regeneratorRuntime.awrap(_this10._client.removeAlias(prevHash, alias));

	                            case 5:
	                            case "end":
	                                return _context10.stop();
	                        }
	                    }
	                }, null, _this10);
	            });
	        }

	        /**
	         * Removes aliases from the memberId
	         *
	         * @param {Array} aliases - aliases to remove
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "removeAliases",
	        value: function removeAliases(aliases) {
	            var _this11 = this;

	            return _Util2.default.callAsync(this.removeAliases, function _callee11() {
	                var prevHash;
	                return regeneratorRuntime.async(function _callee11$(_context11) {
	                    while (1) {
	                        switch (_context11.prev = _context11.next) {
	                            case 0:
	                                _context11.next = 2;
	                                return regeneratorRuntime.awrap(_this11._getPreviousHash());

	                            case 2:
	                                prevHash = _context11.sent;
	                                _context11.next = 5;
	                                return regeneratorRuntime.awrap(_this11._client.removeAliases(prevHash, aliases));

	                            case 5:
	                            case "end":
	                                return _context11.stop();
	                        }
	                    }
	                }, null, _this11);
	            });
	        }

	        /**
	         * Set the "normal consumer" rule as member's recovery rule.
	         * (As of Nov 2017, this rule was: To recover, verify an alias.)
	         * @return {Promise} promise containing RecoveryRule proto buffer.
	         */

	    }, {
	        key: "useDefaultRecoveryRule",
	        value: function useDefaultRecoveryRule() {
	            var _this12 = this;

	            return _Util2.default.callAsync(this.useDefaultRecoveryRule, function _callee12() {
	                var agentResponse, prevHash, rule, res;
	                return regeneratorRuntime.async(function _callee12$(_context12) {
	                    while (1) {
	                        switch (_context12.prev = _context12.next) {
	                            case 0:
	                                _context12.next = 2;
	                                return regeneratorRuntime.awrap(_this12._client.getDefaultRecoveryAgent());

	                            case 2:
	                                agentResponse = _context12.sent;
	                                _context12.next = 5;
	                                return regeneratorRuntime.awrap(_this12._getPreviousHash());

	                            case 5:
	                                prevHash = _context12.sent;
	                                rule = {
	                                    recoveryRule: {
	                                        primaryAgent: agentResponse.data.memberId
	                                    }
	                                };
	                                _context12.next = 9;
	                                return regeneratorRuntime.awrap(_this12._client.addRecoveryRule(prevHash, rule));

	                            case 9:
	                                res = _context12.sent;
	                                return _context12.abrupt("return", res.data.member.recoveryRule);

	                            case 11:
	                            case "end":
	                                return _context12.stop();
	                        }
	                    }
	                }, null, _this12);
	            });
	        }

	        /**
	         * Links bank accounts to the member
	         *
	         * @param {string} authorization - bankAuthorization obtained from bank, or
	         * oauthBankAuthorization
	         * @return {Promise} accounts - Promise resolving the the Accounts linked
	         */

	    }, {
	        key: "linkAccounts",
	        value: function linkAccounts(authorization) {
	            var _this13 = this;

	            return _Util2.default.callAsync(this.linkAccounts, function _callee13() {
	                var _res, res;

	                return regeneratorRuntime.async(function _callee13$(_context13) {
	                    while (1) {
	                        switch (_context13.prev = _context13.next) {
	                            case 0:
	                                if (!authorization.accessToken) {
	                                    _context13.next = 7;
	                                    break;
	                                }

	                                _context13.next = 3;
	                                return regeneratorRuntime.awrap(_this13._client.linkAccountsOauth(authorization));

	                            case 3:
	                                _res = _context13.sent;

	                                if (!(_res.data.status === 'FAILURE_BANK_AUTHORIZATION_REQUIRED')) {
	                                    _context13.next = 6;
	                                    break;
	                                }

	                                throw new Error('Cannot link accounts. Must send bankAuthorization retrieved' + ' through push notification');

	                            case 6:
	                                return _context13.abrupt("return", _res.data.accounts);

	                            case 7:
	                                _context13.next = 9;
	                                return regeneratorRuntime.awrap(_this13._client.linkAccounts(authorization));

	                            case 9:
	                                res = _context13.sent;
	                                return _context13.abrupt("return", res.data.accounts);

	                            case 11:
	                            case "end":
	                                return _context13.stop();
	                        }
	                    }
	                }, null, _this13);
	            });
	        }

	        /**
	         * Unlinks bank accounts previously linked by the linkAccounts call.
	         *
	         * @param {Array} accountIds - account ids to unlink
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "unlinkAccounts",
	        value: function unlinkAccounts(accountIds) {
	            var _this14 = this;

	            return _Util2.default.callAsync(this.unlinkAccounts, function _callee14() {
	                return regeneratorRuntime.async(function _callee14$(_context14) {
	                    while (1) {
	                        switch (_context14.prev = _context14.next) {
	                            case 0:
	                                _context14.next = 2;
	                                return regeneratorRuntime.awrap(_this14._client.unlinkAccounts(accountIds));

	                            case 2:
	                            case "end":
	                                return _context14.stop();
	                        }
	                    }
	                }, null, _this14);
	            });
	        }

	        /**
	         * Looks up the member's accounts
	         *
	         * @return {Promise} accounts - Promise resolving to the accounts
	         */

	    }, {
	        key: "getAccounts",
	        value: function getAccounts() {
	            var _this15 = this;

	            return _Util2.default.callAsync(this.getAccounts, function _callee15() {
	                var res;
	                return regeneratorRuntime.async(function _callee15$(_context15) {
	                    while (1) {
	                        switch (_context15.prev = _context15.next) {
	                            case 0:
	                                _context15.next = 2;
	                                return regeneratorRuntime.awrap(_this15._client.getAccounts());

	                            case 2:
	                                res = _context15.sent;
	                                return _context15.abrupt("return", res.data.accounts === undefined ? [] : res.data.accounts);

	                            case 4:
	                            case "end":
	                                return _context15.stop();
	                        }
	                    }
	                }, null, _this15);
	            });
	        }

	        /**
	         * Looks up a member's account by Id
	         *
	         * @param {string} accountId - accountId
	         * @return {Promise} account - Promise resolving to the account
	         */

	    }, {
	        key: "getAccount",
	        value: function getAccount(accountId) {
	            var _this16 = this;

	            return _Util2.default.callAsync(this.getAccount, function _callee16() {
	                var res;
	                return regeneratorRuntime.async(function _callee16$(_context16) {
	                    while (1) {
	                        switch (_context16.prev = _context16.next) {
	                            case 0:
	                                _context16.next = 2;
	                                return regeneratorRuntime.awrap(_this16._client.getAccount(accountId));

	                            case 2:
	                                res = _context16.sent;
	                                return _context16.abrupt("return", res.data.account === undefined ? [] : res.data.account);

	                            case 4:
	                            case "end":
	                                return _context16.stop();
	                        }
	                    }
	                }, null, _this16);
	            });
	        }

	        /**
	         * Gets the default bank account.
	         *
	         * @return {Promise} the default bank account
	         */

	    }, {
	        key: "getDefaultAccount",
	        value: function getDefaultAccount() {
	            var _this17 = this;

	            return _Util2.default.callAsync(this.getDefaultAccount, function _callee17() {
	                var res;
	                return regeneratorRuntime.async(function _callee17$(_context17) {
	                    while (1) {
	                        switch (_context17.prev = _context17.next) {
	                            case 0:
	                                _context17.next = 2;
	                                return regeneratorRuntime.awrap(_this17._client.getDefaultAccount(_this17.memberId()));

	                            case 2:
	                                res = _context17.sent;
	                                return _context17.abrupt("return", res.data.account);

	                            case 4:
	                            case "end":
	                                return _context17.stop();
	                        }
	                    }
	                }, null, _this17);
	            });
	        }

	        /**
	         * Sets the member's default bank account.
	         *
	         * @param {string} accountId - the bank account id
	         * @return {Promise} account - the account if found
	         */

	    }, {
	        key: "setDefaultAccount",
	        value: function setDefaultAccount(accountId) {
	            var _this18 = this;

	            return _Util2.default.callAsync(this.setDefaultAccount, function _callee18() {
	                var res;
	                return regeneratorRuntime.async(function _callee18$(_context18) {
	                    while (1) {
	                        switch (_context18.prev = _context18.next) {
	                            case 0:
	                                _context18.next = 2;
	                                return regeneratorRuntime.awrap(_this18._client.setDefaultAccount(accountId, _this18.memberId()));

	                            case 2:
	                                res = _context18.sent;
	                                return _context18.abrupt("return", res.data.account);

	                            case 4:
	                            case "end":
	                                return _context18.stop();
	                        }
	                    }
	                }, null, _this18);
	            });
	        }

	        /**
	         * Looks up if this account is default.
	         *
	         * @param {string} accountId - the bank account id
	         * @return {Promise} response - true if the account is default; false otherwise
	         */

	    }, {
	        key: "isDefaultAccount",
	        value: function isDefaultAccount(accountId) {
	            var _this19 = this;

	            return _Util2.default.callAsync(this.isDefaultAccount, function _callee19() {
	                return regeneratorRuntime.async(function _callee19$(_context19) {
	                    while (1) {
	                        switch (_context19.prev = _context19.next) {
	                            case 0:
	                                _context19.next = 2;
	                                return regeneratorRuntime.awrap(_this19.getDefaultAccount().id);

	                            case 2:
	                                _context19.t0 = _context19.sent;
	                                _context19.t1 = accountId;
	                                return _context19.abrupt("return", _context19.t0 === _context19.t1);

	                            case 5:
	                            case "end":
	                                return _context19.stop();
	                        }
	                    }
	                }, null, _this19);
	            });
	        }

	        /**
	         * Gets the info of a bank, including a link for pairing accounts at this bank
	         *
	         * @param {string} bankId - id of the bank
	         * @return {Object} bankInfo - info
	         */

	    }, {
	        key: "getBankInfo",
	        value: function getBankInfo(bankId) {
	            var _this20 = this;

	            return _Util2.default.callAsync(this.getBankInfo, function _callee20() {
	                var res;
	                return regeneratorRuntime.async(function _callee20$(_context20) {
	                    while (1) {
	                        switch (_context20.prev = _context20.next) {
	                            case 0:
	                                _context20.next = 2;
	                                return regeneratorRuntime.awrap(_this20._client.getBankInfo(bankId));

	                            case 2:
	                                res = _context20.sent;
	                                return _context20.abrupt("return", res.data.info);

	                            case 4:
	                            case "end":
	                                return _context20.stop();
	                        }
	                    }
	                }, null, _this20);
	            });
	        }

	        /**
	         * Creates a subscriber to receive notifications of member events, such as step up auth,
	         * new device requests, linking account requests, or transfer notifications
	         *
	         * @param {string} handler - who is handling the notifications
	         * @param {Object} handlerInstructions - map of strings with delivery options
	         * @return {Promise} subscriber - Subscriber
	         */

	    }, {
	        key: "subscribeToNotifications",
	        value: function subscribeToNotifications() {
	            var _this21 = this;

	            var handler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "token";
	            var handlerInstructions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	            return _Util2.default.callAsync(this.subscribeToNotifications, function _callee21() {
	                var res;
	                return regeneratorRuntime.async(function _callee21$(_context21) {
	                    while (1) {
	                        switch (_context21.prev = _context21.next) {
	                            case 0:
	                                _context21.next = 2;
	                                return regeneratorRuntime.awrap(_this21._client.subscribeToNotifications(handler, handlerInstructions));

	                            case 2:
	                                res = _context21.sent;
	                                return _context21.abrupt("return", res.data.subscriber);

	                            case 4:
	                            case "end":
	                                return _context21.stop();
	                        }
	                    }
	                }, null, _this21);
	            });
	        }

	        /**
	         * Gets all subscribers for this member
	         *
	         * @return {Promise} - subscribers
	         */

	    }, {
	        key: "getSubscribers",
	        value: function getSubscribers() {
	            var _this22 = this;

	            return _Util2.default.callAsync(this.getSubscribers, function _callee22() {
	                var res;
	                return regeneratorRuntime.async(function _callee22$(_context22) {
	                    while (1) {
	                        switch (_context22.prev = _context22.next) {
	                            case 0:
	                                _context22.next = 2;
	                                return regeneratorRuntime.awrap(_this22._client.getSubscribers());

	                            case 2:
	                                res = _context22.sent;
	                                return _context22.abrupt("return", res.data.subscribers === undefined ? [] : res.data.subscribers);

	                            case 4:
	                            case "end":
	                                return _context22.stop();
	                        }
	                    }
	                }, null, _this22);
	            });
	        }

	        /**
	         * Gets a specific subscriber by Id
	         *
	         * @param {string} subscriberId - id of the subscriber
	         * @return {Promise} - subscriber
	         */

	    }, {
	        key: "getSubscriber",
	        value: function getSubscriber(subscriberId) {
	            var _this23 = this;

	            return _Util2.default.callAsync(this.getSubscriber, function _callee23() {
	                var res;
	                return regeneratorRuntime.async(function _callee23$(_context23) {
	                    while (1) {
	                        switch (_context23.prev = _context23.next) {
	                            case 0:
	                                _context23.next = 2;
	                                return regeneratorRuntime.awrap(_this23._client.getSubscriber(subscriberId));

	                            case 2:
	                                res = _context23.sent;
	                                return _context23.abrupt("return", res.data.subscriber);

	                            case 4:
	                            case "end":
	                                return _context23.stop();
	                        }
	                    }
	                }, null, _this23);
	            });
	        }

	        /**
	         * Gets all notifications for this member
	         *
	         * @param {string} offset - where to start looking
	         * @param {int} limit - how many to look for
	         * @return {Promise} - notifications
	         */

	    }, {
	        key: "getNotifications",
	        value: function getNotifications(offset, limit) {
	            var _this24 = this;

	            return _Util2.default.callAsync(this.getNotifications, function _callee24() {
	                var res, data;
	                return regeneratorRuntime.async(function _callee24$(_context24) {
	                    while (1) {
	                        switch (_context24.prev = _context24.next) {
	                            case 0:
	                                _context24.next = 2;
	                                return regeneratorRuntime.awrap(_this24._client.getNotifications(offset, limit));

	                            case 2:
	                                res = _context24.sent;
	                                data = res.data.notifications === undefined ? [] : res.data.notifications;
	                                return _context24.abrupt("return", {
	                                    data: data,
	                                    offset: res.data.offset
	                                });

	                            case 5:
	                            case "end":
	                                return _context24.stop();
	                        }
	                    }
	                }, null, _this24);
	            });
	        }

	        /**
	         * Gets a specific notification by Id
	         *
	         * @param {string} notificationId - id of the notification
	         * @return {Promise} - notification
	         */

	    }, {
	        key: "getNotification",
	        value: function getNotification(notificationId) {
	            var _this25 = this;

	            return _Util2.default.callAsync(this.getNotification, function _callee25() {
	                var res;
	                return regeneratorRuntime.async(function _callee25$(_context25) {
	                    while (1) {
	                        switch (_context25.prev = _context25.next) {
	                            case 0:
	                                _context25.next = 2;
	                                return regeneratorRuntime.awrap(_this25._client.getNotification(notificationId));

	                            case 2:
	                                res = _context25.sent;
	                                return _context25.abrupt("return", res.data.notification);

	                            case 4:
	                            case "end":
	                                return _context25.stop();
	                        }
	                    }
	                }, null, _this25);
	            });
	        }

	        /**
	         * Unsubscribes from notifications (removes a subscriber)
	         *
	         * @param {string} subscriberId - subscriber to remove
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "unsubscribeFromNotifications",
	        value: function unsubscribeFromNotifications(subscriberId) {
	            var _this26 = this;

	            return _Util2.default.callAsync(this.unsubscribeFromNotifications, function _callee26() {
	                return regeneratorRuntime.async(function _callee26$(_context26) {
	                    while (1) {
	                        switch (_context26.prev = _context26.next) {
	                            case 0:
	                                _context26.next = 2;
	                                return regeneratorRuntime.awrap(_this26._client.unsubscribeFromNotifications(subscriberId));

	                            case 2:
	                            case "end":
	                                return _context26.stop();
	                        }
	                    }
	                }, null, _this26);
	            });
	        }

	        /**
	         * Triggers a token step up notification on the user's app
	         *
	         * @param {Object} stepUp - token step up notification payload
	         * @return {Promise} - notification status
	         */

	    }, {
	        key: "triggerStepUpNotification",
	        value: function triggerStepUpNotification(stepUp) {
	            var _this27 = this;

	            return _Util2.default.callAsync(this.triggerStepUpNotification, function _callee27() {
	                var res;
	                return regeneratorRuntime.async(function _callee27$(_context27) {
	                    while (1) {
	                        switch (_context27.prev = _context27.next) {
	                            case 0:
	                                _context27.next = 2;
	                                return regeneratorRuntime.awrap(_this27._client.triggerStepUpNotification(stepUp));

	                            case 2:
	                                res = _context27.sent;
	                                return _context27.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context27.stop();
	                        }
	                    }
	                }, null, _this27);
	            });
	        }

	        /**
	         * Triggers a balance step up notification on the user's app
	         * @param {Array} accountIds - array of account ids
	         * @return {Promise} - notification status
	         */

	    }, {
	        key: "triggerBalanceStepUpNotification",
	        value: function triggerBalanceStepUpNotification(accountIds) {
	            var _this28 = this;

	            return _Util2.default.callAsync(this.triggerBalanceStepUpNotification, function _callee28() {
	                var res;
	                return regeneratorRuntime.async(function _callee28$(_context28) {
	                    while (1) {
	                        switch (_context28.prev = _context28.next) {
	                            case 0:
	                                _context28.next = 2;
	                                return regeneratorRuntime.awrap(_this28._client.triggerBalanceStepUpNotification(accountIds));

	                            case 2:
	                                res = _context28.sent;
	                                return _context28.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context28.stop();
	                        }
	                    }
	                }, null, _this28);
	            });
	        }

	        /**
	         * Triggers a transaction step up notification on the user's app
	         * @param {String} accountId - account id
	         * @param {String} transactionId - transaction id
	         * @return {Promise} - notification status
	         */

	    }, {
	        key: "triggerTransactionStepUpNotification",
	        value: function triggerTransactionStepUpNotification(accountId, transactionId) {
	            var _this29 = this;

	            return _Util2.default.callAsync(this.triggerTransactionStepUpNotification, function _callee29() {
	                var res;
	                return regeneratorRuntime.async(function _callee29$(_context29) {
	                    while (1) {
	                        switch (_context29.prev = _context29.next) {
	                            case 0:
	                                _context29.next = 2;
	                                return regeneratorRuntime.awrap(_this29._client.triggerTransactionStepUpNotification(accountId, transactionId));

	                            case 2:
	                                res = _context29.sent;
	                                return _context29.abrupt("return", res.data.status);

	                            case 4:
	                            case "end":
	                                return _context29.stop();
	                        }
	                    }
	                }, null, _this29);
	            });
	        }

	        /**
	         * Creates an address for this member, and saves it
	         *
	         * @param {string} name - name of the address (e.g 'Home')
	         * @param {object} address - address
	         * @return {Promise} promise of AddressRecord structure
	         */

	    }, {
	        key: "addAddress",
	        value: function addAddress(name, address) {
	            var _this30 = this;

	            return _Util2.default.callAsync(this.addAddress, function _callee30() {
	                var res;
	                return regeneratorRuntime.async(function _callee30$(_context30) {
	                    while (1) {
	                        switch (_context30.prev = _context30.next) {
	                            case 0:
	                                _context30.next = 2;
	                                return regeneratorRuntime.awrap(_this30._client.addAddress(name, address));

	                            case 2:
	                                res = _context30.sent;
	                                return _context30.abrupt("return", res.data.address);

	                            case 4:
	                            case "end":
	                                return _context30.stop();
	                        }
	                    }
	                }, null, _this30);
	            });
	        }

	        /**
	         * Gets the member's address
	         *
	         * @param {string} addressId - the address id
	         * @return {Promise} address - AddressRecord structure
	         */

	    }, {
	        key: "getAddress",
	        value: function getAddress(addressId) {
	            var _this31 = this;

	            return _Util2.default.callAsync(this.getAddress, function _callee31() {
	                var res;
	                return regeneratorRuntime.async(function _callee31$(_context31) {
	                    while (1) {
	                        switch (_context31.prev = _context31.next) {
	                            case 0:
	                                _context31.next = 2;
	                                return regeneratorRuntime.awrap(_this31._client.getAddress(addressId));

	                            case 2:
	                                res = _context31.sent;
	                                return _context31.abrupt("return", res.data.address);

	                            case 4:
	                            case "end":
	                                return _context31.stop();
	                        }
	                    }
	                }, null, _this31);
	            });
	        }

	        /**
	         * Gets the member's addresses
	         *
	         * @return {Promise} addresses - list of AddressRecord structures
	         */

	    }, {
	        key: "getAddresses",
	        value: function getAddresses() {
	            var _this32 = this;

	            return _Util2.default.callAsync(this.getAddresses, function _callee32() {
	                var res;
	                return regeneratorRuntime.async(function _callee32$(_context32) {
	                    while (1) {
	                        switch (_context32.prev = _context32.next) {
	                            case 0:
	                                _context32.next = 2;
	                                return regeneratorRuntime.awrap(_this32._client.getAddresses());

	                            case 2:
	                                res = _context32.sent;
	                                return _context32.abrupt("return", res.data.addresses === undefined ? [] : res.data.addresses);

	                            case 4:
	                            case "end":
	                                return _context32.stop();
	                        }
	                    }
	                }, null, _this32);
	            });
	        }

	        /**
	         * Deletes a member's address by id
	         *
	         * @param {string} addressId - the address id
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "deleteAddress",
	        value: function deleteAddress(addressId) {
	            var _this33 = this;

	            return _Util2.default.callAsync(this.deleteAddress, function _callee33() {
	                return regeneratorRuntime.async(function _callee33$(_context33) {
	                    while (1) {
	                        switch (_context33.prev = _context33.next) {
	                            case 0:
	                                _context33.next = 2;
	                                return regeneratorRuntime.awrap(_this33._client.deleteAddress(addressId));

	                            case 2:
	                            case "end":
	                                return _context33.stop();
	                        }
	                    }
	                }, null, _this33);
	            });
	        }

	        /**
	         * Replaces the authenticated member's public profile.
	         *
	         * @param {Object} profile - profile to set
	         * @return {Promise} profile - newly-set profile
	         */

	    }, {
	        key: "setProfile",
	        value: function setProfile(profile) {
	            var _this34 = this;

	            return _Util2.default.callAsync(this.setProfile, function _callee34() {
	                var res;
	                return regeneratorRuntime.async(function _callee34$(_context34) {
	                    while (1) {
	                        switch (_context34.prev = _context34.next) {
	                            case 0:
	                                _context34.next = 2;
	                                return regeneratorRuntime.awrap(_this34._client.setProfile(profile));

	                            case 2:
	                                res = _context34.sent;
	                                return _context34.abrupt("return", res.data.profile);

	                            case 4:
	                            case "end":
	                                return _context34.stop();
	                        }
	                    }
	                }, null, _this34);
	            });
	        }

	        /**
	         * Gets a member's public profile.
	         *
	         * @param {string} id - member id whose profile to get
	         * @return {Promise} profile - profile
	         */

	    }, {
	        key: "getProfile",
	        value: function getProfile(id) {
	            var _this35 = this;

	            return _Util2.default.callAsync(this.getProfile, function _callee35() {
	                var res;
	                return regeneratorRuntime.async(function _callee35$(_context35) {
	                    while (1) {
	                        switch (_context35.prev = _context35.next) {
	                            case 0:
	                                _context35.next = 2;
	                                return regeneratorRuntime.awrap(_this35._client.getProfile(id));

	                            case 2:
	                                res = _context35.sent;
	                                return _context35.abrupt("return", res.data.profile);

	                            case 4:
	                            case "end":
	                                return _context35.stop();
	                        }
	                    }
	                }, null, _this35);
	            });
	        }

	        /**
	         * Uploads the authenticated member's public profile.
	         *
	         * @param {string} type - MIME type
	         * @param {Buffer} data - data in bytes
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "setProfilePicture",
	        value: function setProfilePicture(type, data) {
	            var _this36 = this;

	            return _Util2.default.callAsync(this.setProfilePicture, function _callee36() {
	                return regeneratorRuntime.async(function _callee36$(_context36) {
	                    while (1) {
	                        switch (_context36.prev = _context36.next) {
	                            case 0:
	                                _context36.next = 2;
	                                return regeneratorRuntime.awrap(_this36._client.setProfilePicture(type, data));

	                            case 2:
	                            case "end":
	                                return _context36.stop();
	                        }
	                    }
	                }, null, _this36);
	            });
	        }

	        /**
	         * Gets a member's public profile picture.
	         *
	         * @param {string} id - member id whose picture to get
	         * @param {Object} size - desired size category SMALL/MEDIUM/LARGE/ORIGINAL
	         * @return {Object} blob - downloaded blob
	         */

	    }, {
	        key: "getProfilePicture",
	        value: function getProfilePicture(id, size) {
	            var _this37 = this;

	            return _Util2.default.callAsync(this.getProfilePicture, function _callee37() {
	                var res;
	                return regeneratorRuntime.async(function _callee37$(_context37) {
	                    while (1) {
	                        switch (_context37.prev = _context37.next) {
	                            case 0:
	                                _context37.next = 2;
	                                return regeneratorRuntime.awrap(_this37._client.getProfilePicture(id, size));

	                            case 2:
	                                res = _context37.sent;
	                                return _context37.abrupt("return", res.data.blob);

	                            case 4:
	                            case "end":
	                                return _context37.stop();
	                        }
	                    }
	                }, null, _this37);
	            });
	        }

	        /**
	         * Replaces member's receipt contact.
	         *
	         * @param {Object} contact - receipt contact to set: value + type
	         * @return {Promise} empty - empty promise
	         */

	    }, {
	        key: "setReceiptContact",
	        value: function setReceiptContact(contact) {
	            var _this38 = this;

	            return _Util2.default.callAsync(this.setReceiptContact, function _callee38() {
	                return regeneratorRuntime.async(function _callee38$(_context38) {
	                    while (1) {
	                        switch (_context38.prev = _context38.next) {
	                            case 0:
	                                _context38.next = 2;
	                                return regeneratorRuntime.awrap(_this38._client.setReceiptContact(contact));

	                            case 2:
	                            case "end":
	                                return _context38.stop();
	                        }
	                    }
	                }, null, _this38);
	            });
	        }

	        /**
	         * Get member's receipt contact.
	         *
	         * @return {Object} contact - receipt contact: value + type
	         */

	    }, {
	        key: "getReceiptContact",
	        value: function getReceiptContact() {
	            var _this39 = this;

	            return _Util2.default.callAsync(this.getReceiptContact, function _callee39() {
	                var res;
	                return regeneratorRuntime.async(function _callee39$(_context39) {
	                    while (1) {
	                        switch (_context39.prev = _context39.next) {
	                            case 0:
	                                _context39.next = 2;
	                                return regeneratorRuntime.awrap(_this39._client.getReceiptContact());

	                            case 2:
	                                res = _context39.sent;
	                                return _context39.abrupt("return", res.data.contact);

	                            case 4:
	                            case "end":
	                                return _context39.stop();
	                        }
	                    }
	                }, null, _this39);
	            });
	        }

	        /**
	         * Stores a request for a token. Called by a merchant or a TPP that wants access from a user.
	         *
	         * @param {Object} tokenRequest - token request to store
	         * @return {Promise} requestId - requestId
	         */

	    }, {
	        key: "storeTokenRequest",
	        value: function storeTokenRequest(tokenRequest) {
	            var _this40 = this;

	            return _Util2.default.callAsync(this.storeTokenRequest, function _callee40() {
	                var res;
	                return regeneratorRuntime.async(function _callee40$(_context40) {
	                    while (1) {
	                        switch (_context40.prev = _context40.next) {
	                            case 0:
	                                _context40.next = 2;
	                                return regeneratorRuntime.awrap(_this40._client.storeTokenRequest(tokenRequest));

	                            case 2:
	                                res = _context40.sent;
	                                return _context40.abrupt("return", res.data.tokenRequest);

	                            case 4:
	                            case "end":
	                                return _context40.stop();
	                        }
	                    }
	                }, null, _this40);
	            });
	        }

	        /**
	         * Creates a new unendorsed access token.
	         *
	         * @param {Object} alias - the alias of the grantee of the Access Token
	         * @param {array} resources - a list of resources to give access to
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Promise} token - promise of a created Access Token
	         */

	    }, {
	        key: "createAccessToken",
	        value: function createAccessToken(alias, resources, realm) {
	            var _this41 = this;

	            return _Util2.default.callAsync(this.createAccessToken, function _callee41() {
	                return regeneratorRuntime.async(function _callee41$(_context41) {
	                    while (1) {
	                        switch (_context41.prev = _context41.next) {
	                            case 0:
	                                _context41.next = 2;
	                                return regeneratorRuntime.awrap(new _AccessTokenBuilder2.default(_this41._client, _this41, resources).setFromId(_this41.memberId()).setToAlias(alias).setToRealm(realm).execute());

	                            case 2:
	                                return _context41.abrupt("return", _context41.sent);

	                            case 3:
	                            case "end":
	                                return _context41.stop();
	                        }
	                    }
	                }, null, _this41);
	            });
	        }

	        /**
	         * Creates a new access token builder, that must be executed.
	         *
	         * @return {Promise} token - promise of a created Access Token
	         */

	    }, {
	        key: "createAccessTokenBuilder",
	        value: function createAccessTokenBuilder() {
	            var _this42 = this;

	            return _Util2.default.callSync(this.createAccessTokenBuilder, function () {
	                return new _AccessTokenBuilder2.default(_this42._client, _this42, []);
	            });
	        }

	        /**
	         * Cancels the existing token and creates a replacement for it.
	         *
	         * @param {Object} tokenToCancel - the old token to cancel
	         * @param {Array} newResources - the new resources for this token to grant access to
	         * @return {Promise} operationResult - the result of the operation
	         */

	    }, {
	        key: "replaceAccessToken",
	        value: function replaceAccessToken(tokenToCancel, newResources) {
	            var _this43 = this;

	            return _Util2.default.callAsync(this.replaceAccessToken, function _callee42() {
	                var finalTokenToCancel, res;
	                return regeneratorRuntime.async(function _callee42$(_context42) {
	                    while (1) {
	                        switch (_context42.prev = _context42.next) {
	                            case 0:
	                                _context42.next = 2;
	                                return regeneratorRuntime.awrap(_this43._resolveToken(tokenToCancel));

	                            case 2:
	                                finalTokenToCancel = _context42.sent;
	                                _context42.next = 5;
	                                return regeneratorRuntime.awrap(_this43._client.replaceToken(finalTokenToCancel, newResources));

	                            case 5:
	                                res = _context42.sent;
	                                return _context42.abrupt("return", res.data.result);

	                            case 7:
	                            case "end":
	                                return _context42.stop();
	                        }
	                    }
	                }, null, _this43);
	            });
	        }

	        /**
	         * Cancels the existing token, creates a replacement and endorses it.
	         *
	         * @param {Object} tokenToCancel - the old token to cancel
	         * @param {Array} newResources - the new resources for this token to grant access to
	         * @return {Promise} operationResult - the result of the operation
	         */

	    }, {
	        key: "replaceAndEndorseAccessToken",
	        value: function replaceAndEndorseAccessToken(tokenToCancel, newResources) {
	            var _this44 = this;

	            return _Util2.default.callAsync(this.replaceAndEndorseAccessToken, function _callee43() {
	                var finalTokenToCancel, res;
	                return regeneratorRuntime.async(function _callee43$(_context43) {
	                    while (1) {
	                        switch (_context43.prev = _context43.next) {
	                            case 0:
	                                _context43.next = 2;
	                                return regeneratorRuntime.awrap(_this44._resolveToken(tokenToCancel));

	                            case 2:
	                                finalTokenToCancel = _context43.sent;
	                                _context43.next = 5;
	                                return regeneratorRuntime.awrap(_this44._client.replaceAndEndorseToken(finalTokenToCancel, newResources));

	                            case 5:
	                                res = _context43.sent;
	                                return _context43.abrupt("return", res.data.result);

	                            case 7:
	                            case "end":
	                                return _context43.stop();
	                        }
	                    }
	                }, null, _this44);
	            });
	        }

	        /**
	         * @deprecated - use createTransferTokenBuilder instead
	         * Creates a transfer token builder, that when executed, will create a transfer token by
	         * performing an API call.
	         *
	         * @param {double} lifetimeAmount - amount limit on the token
	         * @param {string} currency - 3 letter currency code ('EUR', 'USD', etc)
	         * @return {TransferTokenBuilder} builder - builder for the token
	         */

	    }, {
	        key: "createTransferToken",
	        value: function createTransferToken(lifetimeAmount, currency) {
	            var _this45 = this;

	            return _Util2.default.callSync(this.createTransferToken, function () {
	                return new _TransferTokenBuilder2.default(_this45._client, _this45, lifetimeAmount, currency).setFromId(_this45.memberId());
	            });
	        }

	        /**
	         * Creates a transfer token builder, that when executed, will create a transfer token by
	         * performing an API call.
	         *
	         * @param {double} lifetimeAmount - amount limit on the token
	         * @param {string} currency - 3 letter currency code ('EUR', 'USD', etc)
	         * @return {TransferTokenBuilder} builder - builder for the token
	         */

	    }, {
	        key: "createTransferTokenBuilder",
	        value: function createTransferTokenBuilder(lifetimeAmount, currency) {
	            var _this46 = this;

	            return _Util2.default.callSync(this.createTransferTokenBuilder, function () {
	                return new _TransferTokenBuilder2.default(_this46._client, _this46, lifetimeAmount, currency);
	            });
	        }

	        /**
	         * Looks up a token by its Id
	         *
	         * @param {string} tokenId - id of the token
	         * @return {Promise} token - token
	         */

	    }, {
	        key: "getToken",
	        value: function getToken(tokenId) {
	            var _this47 = this;

	            return _Util2.default.callAsync(this.getToken, function _callee44() {
	                var res;
	                return regeneratorRuntime.async(function _callee44$(_context44) {
	                    while (1) {
	                        switch (_context44.prev = _context44.next) {
	                            case 0:
	                                _context44.next = 2;
	                                return regeneratorRuntime.awrap(_this47._client.getToken(tokenId));

	                            case 2:
	                                res = _context44.sent;
	                                return _context44.abrupt("return", res.data.token);

	                            case 4:
	                            case "end":
	                                return _context44.stop();
	                        }
	                    }
	                }, null, _this47);
	            });
	        }

	        /**
	         * Looks up a existing access token where the calling member is the grantor and given member is
	         * the grantee.
	         *
	         * @param {string} toMemberId - beneficiary of the active access token
	         * @return {Promise} token - access token returned by the server
	         */

	    }, {
	        key: "getActiveAccessToken",
	        value: function getActiveAccessToken(toMemberId) {
	            var _this48 = this;

	            return _Util2.default.callAsync(this.getActiveAccessToken, function _callee45() {
	                var res;
	                return regeneratorRuntime.async(function _callee45$(_context45) {
	                    while (1) {
	                        switch (_context45.prev = _context45.next) {
	                            case 0:
	                                _context45.next = 2;
	                                return regeneratorRuntime.awrap(_this48._client.getActiveAccessToken(toMemberId));

	                            case 2:
	                                res = _context45.sent;
	                                return _context45.abrupt("return", res.data.token);

	                            case 4:
	                            case "end":
	                                return _context45.stop();
	                        }
	                    }
	                }, null, _this48);
	            });
	        }

	        /**
	         * Looks up all transfer tokens
	         *
	         * @param {string} offset - where to start looking
	         * @param {int} limit - how many to look for
	         * @return {Promise} tokens - returns a list of Transfer Tokens
	         */

	    }, {
	        key: "getTransferTokens",
	        value: function getTransferTokens(offset, limit) {
	            var _this49 = this;

	            return _Util2.default.callAsync(this.getTransferTokens, function _callee46() {
	                var res, data;
	                return regeneratorRuntime.async(function _callee46$(_context46) {
	                    while (1) {
	                        switch (_context46.prev = _context46.next) {
	                            case 0:
	                                _context46.next = 2;
	                                return regeneratorRuntime.awrap(_this49._client.getTokens('TRANSFER', offset, limit));

	                            case 2:
	                                res = _context46.sent;
	                                data = res.data.tokens === undefined ? [] : res.data.tokens;
	                                return _context46.abrupt("return", {
	                                    data: data,
	                                    offset: res.data.offset
	                                });

	                            case 5:
	                            case "end":
	                                return _context46.stop();
	                        }
	                    }
	                }, null, _this49);
	            });
	        }

	        /**
	         * Looks up all access tokens
	         *
	         * @param {string} offset - where to start looking
	         * @param {int} limit - how many to look for
	         * @return {Promise} access tokens - returns a list of access tokens
	         */

	    }, {
	        key: "getAccessTokens",
	        value: function getAccessTokens(offset, limit) {
	            var _this50 = this;

	            return _Util2.default.callAsync(this.getAccessTokens, function _callee47() {
	                var res, data;
	                return regeneratorRuntime.async(function _callee47$(_context47) {
	                    while (1) {
	                        switch (_context47.prev = _context47.next) {
	                            case 0:
	                                _context47.next = 2;
	                                return regeneratorRuntime.awrap(_this50._client.getTokens('ACCESS', offset, limit));

	                            case 2:
	                                res = _context47.sent;
	                                data = res.data.tokens === undefined ? [] : res.data.tokens;
	                                return _context47.abrupt("return", {
	                                    data: data,
	                                    offset: res.data.offset
	                                });

	                            case 5:
	                            case "end":
	                                return _context47.stop();
	                        }
	                    }
	                }, null, _this50);
	            });
	        }

	        /**
	         * Endorses a token. If this SDK client doesn't have a sufficiently
	         * privileged key to endorse the token, this will return
	         * MORE_SIGNATURES_NEEDED and the system pushes a notification to
	         * the member prompting them to use a higher-privilege key.
	         *
	         * @param {Token} token - Transfer token to endorse. Can also be a {string} tokenId
	         * @return {Promise} token - Promise of endorsed transfer token
	         */

	    }, {
	        key: "endorseToken",
	        value: function endorseToken(token) {
	            var _this51 = this;

	            return _Util2.default.callAsync(this.endorseToken, function _callee48() {
	                var finalToken, endorsed;
	                return regeneratorRuntime.async(function _callee48$(_context48) {
	                    while (1) {
	                        switch (_context48.prev = _context48.next) {
	                            case 0:
	                                _context48.next = 2;
	                                return regeneratorRuntime.awrap(_this51._resolveToken(token));

	                            case 2:
	                                finalToken = _context48.sent;
	                                _context48.next = 5;
	                                return regeneratorRuntime.awrap(_this51._client.endorseToken(finalToken));

	                            case 5:
	                                endorsed = _context48.sent;

	                                if (typeof token !== 'string' && !(token instanceof String)) {
	                                    token.payloadSignatures = endorsed.data.result.token.payloadSignatures;
	                                }
	                                return _context48.abrupt("return", endorsed.data.result);

	                            case 8:
	                            case "end":
	                                return _context48.stop();
	                        }
	                    }
	                }, null, _this51);
	            });
	        }

	        /**
	         * Cancels a token. (Called by the payer or the redeemer)
	         *
	         * @param {Token} token - token to cancel. Can also be a {string} tokenId
	         * @return {Promise} TokenOperationResult - cancelled token
	         */

	    }, {
	        key: "cancelToken",
	        value: function cancelToken(token) {
	            var _this52 = this;

	            return _Util2.default.callAsync(this.cancelToken, function _callee49() {
	                var finalToken, cancelled;
	                return regeneratorRuntime.async(function _callee49$(_context49) {
	                    while (1) {
	                        switch (_context49.prev = _context49.next) {
	                            case 0:
	                                _context49.next = 2;
	                                return regeneratorRuntime.awrap(_this52._resolveToken(token));

	                            case 2:
	                                finalToken = _context49.sent;
	                                _context49.next = 5;
	                                return regeneratorRuntime.awrap(_this52._client.cancelToken(finalToken));

	                            case 5:
	                                cancelled = _context49.sent;

	                                if (typeof token !== 'string' && !(token instanceof String)) {
	                                    token.payloadSignatures = cancelled.data.result.token.payloadSignatures;
	                                }
	                                return _context49.abrupt("return", cancelled.data.result);

	                            case 8:
	                            case "end":
	                                return _context49.stop();
	                        }
	                    }
	                }, null, _this52);
	            });
	        }

	        /**
	         * Generates a blocking function to cancel a token. (Called by the payer or the redeemer)
	         *
	         * @param {Token} token - token to cancel. Can also be a {string} tokenId
	         * @return {Function} blocking function to cancel the token
	         */

	    }, {
	        key: "getBlockingCancelTokenFunction",
	        value: function getBlockingCancelTokenFunction(token) {
	            var _this53 = this;

	            return _Util2.default.callAsync(this.getBlockingCancelTokenFunction, function _callee50() {
	                var finalToken, cancelled;
	                return regeneratorRuntime.async(function _callee50$(_context50) {
	                    while (1) {
	                        switch (_context50.prev = _context50.next) {
	                            case 0:
	                                _context50.next = 2;
	                                return regeneratorRuntime.awrap(_this53._resolveToken(token));

	                            case 2:
	                                finalToken = _context50.sent;
	                                _context50.next = 5;
	                                return regeneratorRuntime.awrap(_this53._client.cancelToken(finalToken, true));

	                            case 5:
	                                cancelled = _context50.sent;

	                                if (!(cancelled && cancelled.data && typeof cancelled.data.dispatchRequest === 'function')) {
	                                    _context50.next = 8;
	                                    break;
	                                }

	                                return _context50.abrupt("return", cancelled.data.dispatchRequest);

	                            case 8:
	                            case "end":
	                                return _context50.stop();
	                        }
	                    }
	                }, null, _this53);
	            });
	        }

	        /**
	         * Redeems a token. (Called by the payee or redeemer)
	         *
	         * @param {object} token - token to redeem. Can also be a {string} tokenId
	         * @param {int} amount - amount to redeemer
	         * @param {string} currency - currency to redeem
	         * @param {string} description - optional transfer description
	         * @param {Array} destinations - transfer destinations
	         * @param {string} refId - Id that will be set on created Transfer.
	         *                         Token uses this to detect duplicates.
	         *                         Caller might use this to recognize the transfer.
	         *                         If param empty, transfer will have random refId.
	         * @return {Promise} transfer - Transfer created as a result of this redeem call
	         */

	    }, {
	        key: "redeemToken",
	        value: function redeemToken(token, amount, currency, description) {
	            var _this54 = this;

	            var destinations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
	            var refId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

	            return _Util2.default.callAsync(this.redeemToken, function _callee51() {
	                var finalToken, res;
	                return regeneratorRuntime.async(function _callee51$(_context51) {
	                    while (1) {
	                        switch (_context51.prev = _context51.next) {
	                            case 0:
	                                _context51.next = 2;
	                                return regeneratorRuntime.awrap(_this54._resolveToken(token));

	                            case 2:
	                                finalToken = _context51.sent;

	                                if (amount === undefined) {
	                                    amount = finalToken.payload.transfer.lifetimeAmount;
	                                }
	                                if (currency === undefined) {
	                                    currency = finalToken.payload.transfer.currency;
	                                }
	                                if (description === undefined) {
	                                    description = finalToken.payload.description;
	                                }

	                                if (!(_Util2.default.countDecimals(amount) > _config2.default.decimalPrecision)) {
	                                    _context51.next = 8;
	                                    break;
	                                }

	                                throw new Error("Number of decimals in amount should be at most " + _config2.default.decimalPrecision);

	                            case 8:
	                                _context51.next = 10;
	                                return regeneratorRuntime.awrap(_this54._client.redeemToken(finalToken, amount, currency, description, destinations, refId));

	                            case 10:
	                                res = _context51.sent;
	                                return _context51.abrupt("return", res.data.transfer);

	                            case 12:
	                            case "end":
	                                return _context51.stop();
	                        }
	                    }
	                }, null, _this54);
	            });
	        }

	        /**
	         * Looks up a transfer
	         *
	         * @param {string} transferId - id to look up
	         * @return {Promise} transfer - transfer if found
	         */

	    }, {
	        key: "getTransfer",
	        value: function getTransfer(transferId) {
	            var _this55 = this;

	            return _Util2.default.callAsync(this.getTransfer, function _callee52() {
	                var res;
	                return regeneratorRuntime.async(function _callee52$(_context52) {
	                    while (1) {
	                        switch (_context52.prev = _context52.next) {
	                            case 0:
	                                _context52.next = 2;
	                                return regeneratorRuntime.awrap(_this55._client.getTransfer(transferId));

	                            case 2:
	                                res = _context52.sent;
	                                return _context52.abrupt("return", res.data.transfer);

	                            case 4:
	                            case "end":
	                                return _context52.stop();
	                        }
	                    }
	                }, null, _this55);
	            });
	        }

	        /**
	         * Looks up all of the member's transfers
	         *
	         * @param {string} tokenId - token to use for lookup
	         * @param {string} offset - where to start looking
	         * @param {int} limit - how many to retrieve
	         * @return {Promise} transfers - Transfers
	         */

	    }, {
	        key: "getTransfers",
	        value: function getTransfers(tokenId, offset, limit) {
	            var _this56 = this;

	            return _Util2.default.callAsync(this.getTransfers, function _callee53() {
	                var res, data;
	                return regeneratorRuntime.async(function _callee53$(_context53) {
	                    while (1) {
	                        switch (_context53.prev = _context53.next) {
	                            case 0:
	                                _context53.next = 2;
	                                return regeneratorRuntime.awrap(_this56._client.getTransfers(tokenId, offset, limit));

	                            case 2:
	                                res = _context53.sent;
	                                data = res.data.transfers === undefined ? [] : res.data.transfers;
	                                return _context53.abrupt("return", {
	                                    data: data,
	                                    offset: res.data.offset
	                                });

	                            case 5:
	                            case "end":
	                                return _context53.stop();
	                        }
	                    }
	                }, null, _this56);
	            });
	        }

	        /**
	         * Looks up the balance of an account
	         *
	         * @param {string} accountId - id of the account
	         * @param {string} keyLevel - key level
	         * @return {Promise} balance - Promise of get balance response object
	         */

	    }, {
	        key: "getBalance",
	        value: function getBalance(accountId, keyLevel) {
	            var _this57 = this;

	            return _Util2.default.callAsync(this.getBalance, function _callee54() {
	                var res;
	                return regeneratorRuntime.async(function _callee54$(_context54) {
	                    while (1) {
	                        switch (_context54.prev = _context54.next) {
	                            case 0:
	                                _context54.next = 2;
	                                return regeneratorRuntime.awrap(_this57._client.getBalance(accountId, keyLevel));

	                            case 2:
	                                res = _context54.sent;
	                                return _context54.abrupt("return", res.data);

	                            case 4:
	                            case "end":
	                                return _context54.stop();
	                        }
	                    }
	                }, null, _this57);
	            });
	        }

	        /**
	         * Looks up the balances of an array of accounts
	         *
	         * @param {Array} accountIds - array of account ids
	         * @param {string} keyLevel - key level
	         * @return {Promise} balance - Promise of get balances response object
	         */

	    }, {
	        key: "getBalances",
	        value: function getBalances(accountIds, keyLevel) {
	            var _this58 = this;

	            return _Util2.default.callAsync(this.getBalances, function _callee55() {
	                var res;
	                return regeneratorRuntime.async(function _callee55$(_context55) {
	                    while (1) {
	                        switch (_context55.prev = _context55.next) {
	                            case 0:
	                                _context55.next = 2;
	                                return regeneratorRuntime.awrap(_this58._client.getBalances(accountIds, keyLevel));

	                            case 2:
	                                res = _context55.sent;
	                                return _context55.abrupt("return", res.data);

	                            case 4:
	                            case "end":
	                                return _context55.stop();
	                        }
	                    }
	                }, null, _this58);
	            });
	        }

	        /**
	         * Looks up a transaction
	         *
	         * @param {string} accountId - id of the account
	         * @param {string} transactionId - which transaction to look up
	         * @param {string} keyLevel - key level
	         * @return {Promise} transaction - the Transaction
	         */

	    }, {
	        key: "getTransaction",
	        value: function getTransaction(accountId, transactionId, keyLevel) {
	            var _this59 = this;

	            return _Util2.default.callAsync(this.getTransaction, function _callee56() {
	                var res;
	                return regeneratorRuntime.async(function _callee56$(_context56) {
	                    while (1) {
	                        switch (_context56.prev = _context56.next) {
	                            case 0:
	                                _context56.next = 2;
	                                return regeneratorRuntime.awrap(_this59._client.getTransaction(accountId, transactionId, keyLevel));

	                            case 2:
	                                res = _context56.sent;
	                                return _context56.abrupt("return", res.data.transaction);

	                            case 4:
	                            case "end":
	                                return _context56.stop();
	                        }
	                    }
	                }, null, _this59);
	            });
	        }

	        /**
	         * Looks up all of the member's transactions for an account
	         *
	         * @param {string} accountId - id of the account
	         * @param {string} offset - where to start looking
	         * @param {int} limit - how many to retrieve
	         * @param {string} keyLevel - key level
	         * @return {Promise} transactions - Transactions
	         */

	    }, {
	        key: "getTransactions",
	        value: function getTransactions(accountId, offset, limit, keyLevel) {
	            var _this60 = this;

	            return _Util2.default.callAsync(this.getTransactions, function _callee57() {
	                var res, data;
	                return regeneratorRuntime.async(function _callee57$(_context57) {
	                    while (1) {
	                        switch (_context57.prev = _context57.next) {
	                            case 0:
	                                _context57.next = 2;
	                                return regeneratorRuntime.awrap(_this60._client.getTransactions(accountId, offset, limit, keyLevel));

	                            case 2:
	                                res = _context57.sent;
	                                data = res.data.transactions === undefined ? [] : res.data.transactions;
	                                return _context57.abrupt("return", {
	                                    data: data,
	                                    offset: res.data.offset
	                                });

	                            case 5:
	                            case "end":
	                                return _context57.stop();
	                        }
	                    }
	                }, null, _this60);
	            });
	        }

	        /**
	         * Uploads a blob to the server.
	         *
	         * @param {string} ownerId - owner of the blob
	         * @param {string} type - MIME type
	         * @param {string} name - name of the file
	         * @param {Buffer} data - data in bytes
	         * @return {Object} attachment - attachment
	         */

	    }, {
	        key: "createBlob",
	        value: function createBlob(ownerId, type, name, data) {
	            var _this61 = this;

	            return _Util2.default.callAsync(this.createBlob, function _callee58() {
	                var res;
	                return regeneratorRuntime.async(function _callee58$(_context58) {
	                    while (1) {
	                        switch (_context58.prev = _context58.next) {
	                            case 0:
	                                _context58.next = 2;
	                                return regeneratorRuntime.awrap(_this61._client.createBlob(ownerId, type, name, data));

	                            case 2:
	                                res = _context58.sent;
	                                return _context58.abrupt("return", {
	                                    blobId: res.data.blobId,
	                                    type: type,
	                                    name: name
	                                });

	                            case 4:
	                            case "end":
	                                return _context58.stop();
	                        }
	                    }
	                }, null, _this61);
	            });
	        }

	        /**
	         * Downloads a blob from the server.
	         *
	         * @param {string} blobId - id of the blob
	         * @return {Object} blob - downloaded blob
	         */

	    }, {
	        key: "getBlob",
	        value: function getBlob(blobId) {
	            var _this62 = this;

	            return _Util2.default.callAsync(this.getBlob, function _callee59() {
	                var res;
	                return regeneratorRuntime.async(function _callee59$(_context59) {
	                    while (1) {
	                        switch (_context59.prev = _context59.next) {
	                            case 0:
	                                _context59.next = 2;
	                                return regeneratorRuntime.awrap(_this62._client.getBlob(blobId));

	                            case 2:
	                                res = _context59.sent;
	                                return _context59.abrupt("return", res.data.blob);

	                            case 4:
	                            case "end":
	                                return _context59.stop();
	                        }
	                    }
	                }, null, _this62);
	            });
	        }

	        /**
	         * Downloads a blob from the server, that is attached to a token.
	         *
	         * @param {string} tokenId - id of the token
	         * @param {string} blobId - id of the blob
	         * @return {Object} blob - downloaded blob
	         */

	    }, {
	        key: "getTokenBlob",
	        value: function getTokenBlob(tokenId, blobId) {
	            var _this63 = this;

	            return _Util2.default.callAsync(this.getTokenBlob, function _callee60() {
	                var res;
	                return regeneratorRuntime.async(function _callee60$(_context60) {
	                    while (1) {
	                        switch (_context60.prev = _context60.next) {
	                            case 0:
	                                _context60.next = 2;
	                                return regeneratorRuntime.awrap(_this63._client.getTokenBlob(tokenId, blobId));

	                            case 2:
	                                res = _context60.sent;
	                                return _context60.abrupt("return", res.data.blob);

	                            case 4:
	                            case "end":
	                                return _context60.stop();
	                        }
	                    }
	                }, null, _this63);
	            });
	        }

	        /**
	         * Sign with a Token signature a token request state payload.
	         *
	         * @param {string} tokenId - token id
	         * @param {string} state - url state
	         * @return {Object} response - response to the api call
	         */

	    }, {
	        key: "signTokenRequestState",
	        value: function signTokenRequestState(tokenId, state) {
	            var _this64 = this;

	            return _Util2.default.callAsync(this.signTokenRequestState, function _callee61() {
	                var res;
	                return regeneratorRuntime.async(function _callee61$(_context61) {
	                    while (1) {
	                        switch (_context61.prev = _context61.next) {
	                            case 0:
	                                _context61.next = 2;
	                                return regeneratorRuntime.awrap(_this64._client.signTokenRequestState(tokenId, state));

	                            case 2:
	                                res = _context61.sent;
	                                return _context61.abrupt("return", res.data.signature);

	                            case 4:
	                            case "end":
	                                return _context61.stop();
	                        }
	                    }
	                }, null, _this64);
	            });
	        }

	        /**
	         * Deletes the member.
	         *
	         * @return {Object} response - response to the api call
	         */

	    }, {
	        key: "deleteMember",
	        value: function deleteMember() {
	            var _this65 = this;

	            return _Util2.default.callAsync(this.deleteMember, function _callee62() {
	                return regeneratorRuntime.async(function _callee62$(_context62) {
	                    while (1) {
	                        switch (_context62.prev = _context62.next) {
	                            case 0:
	                                _context62.next = 2;
	                                return regeneratorRuntime.awrap(_this65._client.deleteMember());

	                            case 2:
	                            case "end":
	                                return _context62.stop();
	                        }
	                    }
	                }, null, _this65);
	            });
	        }

	        /**
	         * Creates a test bank account in a fake bank
	         *
	         * @param {double} balance - balance of the account
	         * @param {string} currency - currency of the account
	         * @return {Array} bank authorization to use with linkAccounts
	         */

	    }, {
	        key: "createTestBankAccount",
	        value: function createTestBankAccount(balance, currency) {
	            var _this66 = this;

	            return _Util2.default.callAsync(this.createTestBankAccount, function _callee63() {
	                var res;
	                return regeneratorRuntime.async(function _callee63$(_context63) {
	                    while (1) {
	                        switch (_context63.prev = _context63.next) {
	                            case 0:
	                                _context63.next = 2;
	                                return regeneratorRuntime.awrap(_this66._client.createTestBankAccount(balance, currency));

	                            case 2:
	                                res = _context63.sent;
	                                return _context63.abrupt("return", res.data.bankAuthorization);

	                            case 4:
	                            case "end":
	                                return _context63.stop();
	                        }
	                    }
	                }, null, _this66);
	            });
	        }

	        /**
	         * Creates a test bank account in a fake bank
	         *
	         * @param {double} balance - balance of the account
	         * @param {string} currency - currency of the account
	         * @return {Array} bank authorization to use with linkAccounts
	         */

	    }, {
	        key: "createTestBankAccountOauth",
	        value: function createTestBankAccountOauth(balance, currency) {
	            var _this67 = this;

	            return _Util2.default.callAsync(this.createTestBankAccountOauth, function _callee64() {
	                var res;
	                return regeneratorRuntime.async(function _callee64$(_context64) {
	                    while (1) {
	                        switch (_context64.prev = _context64.next) {
	                            case 0:
	                                _context64.next = 2;
	                                return regeneratorRuntime.awrap(_this67._client.createTestBankAccount(balance, currency));

	                            case 2:
	                                res = _context64.sent;
	                                return _context64.abrupt("return", res.data.authorization);

	                            case 4:
	                            case "end":
	                                return _context64.stop();
	                        }
	                    }
	                }, null, _this67);
	            });
	        }
	        /**
	         * Gets test bank notification.
	         *
	         * @param {string} subscriberId - id of subscriber
	         * @param {string} notificationId - id of notification
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTestBankNotification",
	        value: function getTestBankNotification(subscriberId, notificationId) {
	            var _this68 = this;

	            return _Util2.default.callAsync(this.getTestBankNotification, function _callee65() {
	                var res;
	                return regeneratorRuntime.async(function _callee65$(_context65) {
	                    while (1) {
	                        switch (_context65.prev = _context65.next) {
	                            case 0:
	                                _context65.next = 2;
	                                return regeneratorRuntime.awrap(_this68._client.getTestBankNotification(subscriberId, notificationId));

	                            case 2:
	                                res = _context65.sent;
	                                return _context65.abrupt("return", res.data.notification);

	                            case 4:
	                            case "end":
	                                return _context65.stop();
	                        }
	                    }
	                }, null, _this68);
	            });
	        }

	        /**
	         * Gets test bank notifications.
	         *
	         * @param {string} subscriberId - id of subscriber
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTestBankNotifications",
	        value: function getTestBankNotifications(subscriberId) {
	            var _this69 = this;

	            return _Util2.default.callAsync(this.getTestBankNotifications, function _callee66() {
	                var res;
	                return regeneratorRuntime.async(function _callee66$(_context66) {
	                    while (1) {
	                        switch (_context66.prev = _context66.next) {
	                            case 0:
	                                _context66.next = 2;
	                                return regeneratorRuntime.awrap(_this69._client.getTestBankNotifications(subscriberId));

	                            case 2:
	                                res = _context66.sent;
	                                return _context66.abrupt("return", res.data.notifications);

	                            case 4:
	                            case "end":
	                                return _context66.stop();
	                        }
	                    }
	                }, null, _this69);
	            });
	        }
	    }, {
	        key: "_getPreviousHash",
	        value: function _getPreviousHash() {
	            var _this70 = this;

	            return _Util2.default.callAsync(this._getPreviousHash, function _callee67() {
	                var member;
	                return regeneratorRuntime.async(function _callee67$(_context67) {
	                    while (1) {
	                        switch (_context67.prev = _context67.next) {
	                            case 0:
	                                _context67.next = 2;
	                                return regeneratorRuntime.awrap(_this70._getMember());

	                            case 2:
	                                member = _context67.sent;
	                                return _context67.abrupt("return", member.lastHash);

	                            case 4:
	                            case "end":
	                                return _context67.stop();
	                        }
	                    }
	                }, null, _this70);
	            });
	        }
	    }, {
	        key: "_getMember",
	        value: function _getMember() {
	            var _this71 = this;

	            return _Util2.default.callAsync(this._getMember, function _callee68() {
	                var res;
	                return regeneratorRuntime.async(function _callee68$(_context68) {
	                    while (1) {
	                        switch (_context68.prev = _context68.next) {
	                            case 0:
	                                _context68.next = 2;
	                                return regeneratorRuntime.awrap(_this71._unauthenticatedClient.getMember(_this71._id));

	                            case 2:
	                                res = _context68.sent;
	                                return _context68.abrupt("return", res.data.member);

	                            case 4:
	                            case "end":
	                                return _context68.stop();
	                        }
	                    }
	                }, null, _this71);
	            });
	        }
	    }, {
	        key: "_resolveToken",
	        value: function _resolveToken(token) {
	            var _this72 = this;

	            return new Promise(function (resolve, reject) {
	                if (typeof token === 'string' || token instanceof String) {
	                    _this72.getToken(token).then(function (lookedUp) {
	                        return resolve(lookedUp);
	                    });
	                } else {
	                    resolve(token); // Token, already in json representation
	                }
	            });
	        }
	    }]);

	    return Member;
	}();

	exports.default = Member;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable camelcase */

	var _Crypto = __webpack_require__(4);

	var _Crypto2 = _interopRequireDefault(_Crypto);

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	var _AuthHeader = __webpack_require__(29);

	var _AuthHeader2 = _interopRequireDefault(_AuthHeader);

	var _AuthContext = __webpack_require__(31);

	var _AuthContext2 = _interopRequireDefault(_AuthContext);

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	var _ErrorHandler = __webpack_require__(32);

	var _ErrorHandler2 = _interopRequireDefault(_ErrorHandler);

	var _DeveloperHeader = __webpack_require__(33);

	var _DeveloperHeader2 = _interopRequireDefault(_DeveloperHeader);

	var _VersionHeader = __webpack_require__(34);

	var _VersionHeader2 = _interopRequireDefault(_VersionHeader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var base64js = __webpack_require__(35);
	var stringify = __webpack_require__(5);
	var axios = __webpack_require__(36);

	var BlockingAdapter = __webpack_require__(37);

	/**
	 * Client for making authenticated requests to the Token gateway.
	 */

	var AuthHttpClient = function () {
	    /**
	     * Initializes the client for the environment, memberId, and CryptoEngine. Sets up signers using
	     * the CryptoEngine, for Low, Standard, and Privileged keys, which will be used to sign
	     * appropriate requests.
	     *
	     * @param {string} env - desired env, such as 'prd'
	     * @param {string} memberId - member making the requests
	     * @param {Object} cryptoEngine - engines to use for signing
	     * @param {string} developerKey - the developer key
	     * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
	     * @param {bool} loggingEnabled - enable HTTP error logging if true
	     * call error. For example: SDK version mismatch
	     * @param {string} customSdkUrl - set to override the default sdk url
	     */
	    function AuthHttpClient(env, memberId, cryptoEngine, developerKey, globalRpcErrorCallback, loggingEnabled, customSdkUrl) {
	        _classCallCheck(this, AuthHttpClient);

	        if (!(_config2.default.urls[env] || customSdkUrl)) {
	            throw new Error('Invalid environment string. Please use one of: ' + JSON.stringify(_config2.default.urls));
	        }
	        this._instance = axios.create({
	            baseURL: customSdkUrl || _config2.default.urls[env]
	        });
	        if (loggingEnabled) {
	            _Util2.default.setUpHttpErrorLogging(this._instance);
	        }
	        this._memberId = memberId;
	        this._cryptoEngine = cryptoEngine;

	        this._context = new _AuthContext2.default();
	        this._authHeader = new _AuthHeader2.default(customSdkUrl || _config2.default.urls[env], this);

	        this._developerKey = developerKey;

	        this._resetRequestInterceptor();

	        var errorHandler = new _ErrorHandler2.default(globalRpcErrorCallback);
	        this._instance.interceptors.response.use(null, function (error) {
	            throw errorHandler.handleError(error);
	        });
	    }

	    /**
	     * Creates the necessary signer objects, based on the level requested.
	     * If the level is not available, attempts to fetch a lower level.
	     *
	     * @param {string} level - requested level of key
	     * @return {Promise} signer - object used to sign
	     */


	    _createClass(AuthHttpClient, [{
	        key: "getSigner",
	        value: function getSigner(level) {
	            return regeneratorRuntime.async(function getSigner$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            if (!(level === _config2.default.KeyLevel.LOW)) {
	                                _context.next = 4;
	                                break;
	                            }

	                            _context.next = 3;
	                            return regeneratorRuntime.awrap(this._cryptoEngine.createSigner(_config2.default.KeyLevel.LOW));

	                        case 3:
	                            return _context.abrupt("return", _context.sent);

	                        case 4:
	                            if (!(level === _config2.default.KeyLevel.STANDARD)) {
	                                _context.next = 16;
	                                break;
	                            }

	                            _context.prev = 5;
	                            _context.next = 8;
	                            return regeneratorRuntime.awrap(this._cryptoEngine.createSigner(_config2.default.KeyLevel.STANDARD));

	                        case 8:
	                            return _context.abrupt("return", _context.sent);

	                        case 11:
	                            _context.prev = 11;
	                            _context.t0 = _context["catch"](5);
	                            _context.next = 15;
	                            return regeneratorRuntime.awrap(this._cryptoEngine.createSigner(_config2.default.KeyLevel.LOW));

	                        case 15:
	                            return _context.abrupt("return", _context.sent);

	                        case 16:
	                            if (!(level === _config2.default.KeyLevel.PRIVILEGED)) {
	                                _context.next = 36;
	                                break;
	                            }

	                            _context.prev = 17;
	                            _context.next = 20;
	                            return regeneratorRuntime.awrap(this._cryptoEngine.createSigner(_config2.default.KeyLevel.PRIVILEGED));

	                        case 20:
	                            return _context.abrupt("return", _context.sent);

	                        case 23:
	                            _context.prev = 23;
	                            _context.t1 = _context["catch"](17);
	                            _context.prev = 25;
	                            _context.next = 28;
	                            return regeneratorRuntime.awrap(this._cryptoEngine.createSigner(_config2.default.KeyLevel.STANDARD));

	                        case 28:
	                            return _context.abrupt("return", _context.sent);

	                        case 31:
	                            _context.prev = 31;
	                            _context.t2 = _context["catch"](25);
	                            _context.next = 35;
	                            return regeneratorRuntime.awrap(this._cryptoEngine.createSigner(_config2.default.KeyLevel.LOW));

	                        case 35:
	                            return _context.abrupt("return", _context.sent);

	                        case 36:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this, [[5, 11], [17, 23], [25, 31]]);
	        }
	    }, {
	        key: "_resetRequestInterceptor",
	        value: function _resetRequestInterceptor() {
	            var _this = this;

	            this._instance.interceptors.request.eject(this._interceptor);

	            var versionHeader = new _VersionHeader2.default();
	            var developerHeader = new _DeveloperHeader2.default(this._developerKey);
	            this._interceptor = this._instance.interceptors.request.use(function _callee(request) {
	                return regeneratorRuntime.async(function _callee$(_context2) {
	                    while (1) {
	                        switch (_context2.prev = _context2.next) {
	                            case 0:
	                                _context2.next = 2;
	                                return regeneratorRuntime.awrap(_this._authHeader.addAuthorizationHeader(_this._memberId, request, _this._context));

	                            case 2:
	                                versionHeader.addVersionHeader(request);
	                                developerHeader.addDeveloperHeader(request);
	                                return _context2.abrupt("return", request);

	                            case 5:
	                            case "end":
	                                return _context2.stop();
	                        }
	                    }
	                }, null, _this);
	            });
	        }

	        /**
	         * Use the given access token. (Act on behalf of this member).
	         *
	         * @param {string} accessTokenId - Id of the access token
	         */

	    }, {
	        key: "useAccessToken",
	        value: function useAccessToken(accessTokenId) {
	            this._context.onBehalfOf = accessTokenId;
	            this._resetRequestInterceptor();
	        }

	        /**
	         * Use the given key level to sign the request.
	         *
	         * @param {string} keyLevel - key level
	         */

	    }, {
	        key: "useKeyLevel",
	        value: function useKeyLevel(keyLevel) {
	            this._context.keyLevel = keyLevel;
	            this._resetRequestInterceptor();
	        }

	        /**
	         * Clears the AuthContext, so this client no longer acts on behalf of another member.
	         */

	    }, {
	        key: "clearAccessToken",
	        value: function clearAccessToken() {
	            this._context.onBehalfOf = undefined;
	            this._resetRequestInterceptor();
	        }

	        /**
	         * Sets the customer initiated request flag to true.
	         */

	    }, {
	        key: "setCustomerInitiated",
	        value: function setCustomerInitiated() {
	            this._context.customerInitiated = true;
	        }

	        /**
	         * Subcribes to push notifications.
	         *
	         * @param {string} handler - who is handling the notifications
	         * @param {string} handlerInstructions - how to send the notification
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "subscribeToNotifications",
	        value: function subscribeToNotifications(handler, handlerInstructions) {
	            var req, request;
	            return regeneratorRuntime.async(function subscribeToNotifications$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            req = {
	                                handler: handler,
	                                handlerInstructions: handlerInstructions
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/subscribers",
	                                data: req
	                            };
	                            return _context3.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all subscribers for a member.
	         *
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getSubscribers",
	        value: function getSubscribers() {
	            var request;
	            return regeneratorRuntime.async(function getSubscribers$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/subscribers"
	                            };
	                            return _context4.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a subscriber by id.
	         *
	         * @param {string} subscriberId - Id of the subscriber to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getSubscriber",
	        value: function getSubscriber(subscriberId) {
	            var request;
	            return regeneratorRuntime.async(function getSubscriber$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/subscribers/" + subscriberId
	                            };
	                            return _context5.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all notifications.
	         *
	         * @param {string} offset - where to start looking
	         * @param {Number} limit - how many to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getNotifications",
	        value: function getNotifications(offset, limit) {
	            var request;
	            return regeneratorRuntime.async(function getNotifications$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/notifications?offset=" + offset + "&limit=" + limit
	                            };
	                            return _context6.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a notification by id.
	         *
	         * @param {string} notificationId - Id of the notification to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getNotification",
	        value: function getNotification(notificationId) {
	            var request;
	            return regeneratorRuntime.async(function getNotification$(_context7) {
	                while (1) {
	                    switch (_context7.prev = _context7.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/notifications/" + notificationId
	                            };
	                            return _context7.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context7.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Unsubscribes from notifications (deletes a subscriber).
	         *
	         * @param {string} subscriberId - subscriber to delete
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "unsubscribeFromNotifications",
	        value: function unsubscribeFromNotifications(subscriberId) {
	            var request;
	            return regeneratorRuntime.async(function unsubscribeFromNotifications$(_context8) {
	                while (1) {
	                    switch (_context8.prev = _context8.next) {
	                        case 0:
	                            request = {
	                                method: 'delete',
	                                url: "/subscribers/" + subscriberId
	                            };
	                            return _context8.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context8.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Trigger a token step up notification.
	         *
	         * @param {Object} stepUp - token step up notification payload
	         * @return {Object} response - response to the Api call
	         */

	    }, {
	        key: "triggerStepUpNotification",
	        value: function triggerStepUpNotification(stepUp) {
	            var req, request;
	            return regeneratorRuntime.async(function triggerStepUpNotification$(_context9) {
	                while (1) {
	                    switch (_context9.prev = _context9.next) {
	                        case 0:
	                            req = {
	                                tokenStepUp: stepUp
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/notify/stepup",
	                                data: req
	                            };
	                            return _context9.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context9.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Trigger a balance step up notification.
	         *
	         * @param {Array} accountIds - array of account ids
	         * @return {Object} response - response to the Api call
	         */

	    }, {
	        key: "triggerBalanceStepUpNotification",
	        value: function triggerBalanceStepUpNotification(accountIds) {
	            var req, request;
	            return regeneratorRuntime.async(function triggerBalanceStepUpNotification$(_context10) {
	                while (1) {
	                    switch (_context10.prev = _context10.next) {
	                        case 0:
	                            req = {
	                                balanceStepUp: {
	                                    accountId: accountIds
	                                }
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/notify/stepup",
	                                data: req
	                            };
	                            return _context10.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context10.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Trigger a transaction step up notification.
	         *
	         * @param {string} accountId - account id
	         * @param {string} transactionId - transaction id
	         * @return {Object} response - response to the Api call
	         */

	    }, {
	        key: "triggerTransactionStepUpNotification",
	        value: function triggerTransactionStepUpNotification(accountId, transactionId) {
	            var req, request;
	            return regeneratorRuntime.async(function triggerTransactionStepUpNotification$(_context11) {
	                while (1) {
	                    switch (_context11.prev = _context11.next) {
	                        case 0:
	                            req = {
	                                transactionStepUp: {
	                                    accountId: accountId,
	                                    transactionId: transactionId
	                                }
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/notify/stepup",
	                                data: req
	                            };
	                            return _context11.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context11.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // ADDRESSES
	        //

	        /**
	         * Adds an address to the member.
	         *
	         * @param {string} name - name of the address
	         * @param {Object} address - address to add
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "addAddress",
	        value: function addAddress(name, address) {
	            var signer, req, request;
	            return regeneratorRuntime.async(function addAddress$(_context12) {
	                while (1) {
	                    switch (_context12.prev = _context12.next) {
	                        case 0:
	                            _context12.next = 2;
	                            return regeneratorRuntime.awrap(this.getSigner(_config2.default.KeyLevel.LOW));

	                        case 2:
	                            signer = _context12.sent;
	                            _context12.t0 = name;
	                            _context12.t1 = address;
	                            _context12.t2 = this._memberId;
	                            _context12.t3 = signer.getKeyId();
	                            _context12.next = 9;
	                            return regeneratorRuntime.awrap(signer.signJson(address));

	                        case 9:
	                            _context12.t4 = _context12.sent;
	                            _context12.t5 = {
	                                memberId: _context12.t2,
	                                keyId: _context12.t3,
	                                signature: _context12.t4
	                            };
	                            req = {
	                                name: _context12.t0,
	                                address: _context12.t1,
	                                addressSignature: _context12.t5
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/addresses",
	                                data: req
	                            };
	                            return _context12.abrupt("return", this._instance(request));

	                        case 14:
	                        case "end":
	                            return _context12.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets an address by id.
	         *
	         * @param {string} addressId - address to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getAddress",
	        value: function getAddress(addressId) {
	            var request;
	            return regeneratorRuntime.async(function getAddress$(_context13) {
	                while (1) {
	                    switch (_context13.prev = _context13.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/addresses/" + addressId
	                            };
	                            return _context13.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context13.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all addresses.
	         *
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getAddresses",
	        value: function getAddresses() {
	            var request;
	            return regeneratorRuntime.async(function getAddresses$(_context14) {
	                while (1) {
	                    switch (_context14.prev = _context14.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/addresses"
	                            };
	                            return _context14.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context14.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Deletes an address.
	         *
	         * @param {string} addressId - address to delete
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "deleteAddress",
	        value: function deleteAddress(addressId) {
	            var request;
	            return regeneratorRuntime.async(function deleteAddress$(_context15) {
	                while (1) {
	                    switch (_context15.prev = _context15.next) {
	                        case 0:
	                            request = {
	                                method: 'delete',
	                                url: "/addresses/" + addressId
	                            };
	                            return _context15.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context15.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // PROFILES
	        //

	        /**
	         * Replaces the authenticated member's public profile.
	         *
	         * @param {Object} profile - profile to set
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "setProfile",
	        value: function setProfile(profile) {
	            var req, request;
	            return regeneratorRuntime.async(function setProfile$(_context16) {
	                while (1) {
	                    switch (_context16.prev = _context16.next) {
	                        case 0:
	                            req = {
	                                profile: profile
	                            };
	                            request = {
	                                method: 'put',
	                                url: "/profile",
	                                data: req
	                            };
	                            return _context16.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context16.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a member's public profile.
	         *
	         * @param {string} id - member id whose profile to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getProfile",
	        value: function getProfile(id) {
	            var request;
	            return regeneratorRuntime.async(function getProfile$(_context17) {
	                while (1) {
	                    switch (_context17.prev = _context17.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/members/" + id + "/profile"
	                            };
	                            return _context17.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context17.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Uploads member's public profile picture.
	         *
	         * @param {string} type - MIME type
	         * @param {Buffer} data - data in bytes
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "setProfilePicture",
	        value: function setProfilePicture(type, data) {
	            var req, request;
	            return regeneratorRuntime.async(function setProfilePicture$(_context18) {
	                while (1) {
	                    switch (_context18.prev = _context18.next) {
	                        case 0:
	                            req = {
	                                payload: {
	                                    ownerId: this._memberId,
	                                    type: type,
	                                    name: "profile",
	                                    data: base64js.fromByteArray(data),
	                                    accessMode: "PUBLIC"
	                                }
	                            };
	                            request = {
	                                method: 'put',
	                                url: "/profilepicture",
	                                data: req
	                            };
	                            return _context18.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context18.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a member's public profile picture.
	         *
	         * @param {string} id - member Id whose picture to get
	         * @param {Object} size - desired size category: SMALL/MEDIUM/LARGE/ORIGINAL
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getProfilePicture",
	        value: function getProfilePicture(id, size) {
	            var request;
	            return regeneratorRuntime.async(function getProfilePicture$(_context19) {
	                while (1) {
	                    switch (_context19.prev = _context19.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/members/" + id + "/profilepicture/" + size
	                            };
	                            return _context19.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context19.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Replaces member's receipt contact.
	         *
	         * @param {Object} contact - receipt contact to set: value + type
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "setReceiptContact",
	        value: function setReceiptContact(contact) {
	            var req, request;
	            return regeneratorRuntime.async(function setReceiptContact$(_context20) {
	                while (1) {
	                    switch (_context20.prev = _context20.next) {
	                        case 0:
	                            req = {
	                                contact: contact
	                            };
	                            request = {
	                                method: 'put',
	                                url: "/receipt-contact",
	                                data: req
	                            };
	                            return _context20.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context20.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets member's receipt contact.
	         *
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getReceiptContact",
	        value: function getReceiptContact() {
	            var request;
	            return regeneratorRuntime.async(function getReceiptContact$(_context21) {
	                while (1) {
	                    switch (_context21.prev = _context21.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/receipt-contact"
	                            };
	                            return _context21.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context21.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // ACCOUNTS
	        //

	        /**
	         * Links accounts to the member.
	         *
	         * @param {Object} bankAuthorization - encrypted authorization to accounts
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "linkAccounts",
	        value: function linkAccounts(bankAuthorization) {
	            var req, request;
	            return regeneratorRuntime.async(function linkAccounts$(_context22) {
	                while (1) {
	                    switch (_context22.prev = _context22.next) {
	                        case 0:
	                            req = {
	                                bankAuthorization: bankAuthorization
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/accounts",
	                                data: req
	                            };
	                            return _context22.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context22.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Links accounts to the member.
	         *
	         * @param {string} authorization - oauthBankAuthorization continaing bank_id and
	         * access_token
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "linkAccountsOauth",
	        value: function linkAccountsOauth(authorization) {
	            var req, request;
	            return regeneratorRuntime.async(function linkAccountsOauth$(_context23) {
	                while (1) {
	                    switch (_context23.prev = _context23.next) {
	                        case 0:
	                            req = {
	                                authorization: authorization
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/bank-accounts",
	                                data: req
	                            };
	                            return _context23.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context23.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Unlinks bank accounts previously linked by the linkAccounts call.
	         *
	         * @param {Array} accountIds - account ids to unlink
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "unlinkAccounts",
	        value: function unlinkAccounts(accountIds) {
	            var req, request;
	            return regeneratorRuntime.async(function unlinkAccounts$(_context24) {
	                while (1) {
	                    switch (_context24.prev = _context24.next) {
	                        case 0:
	                            req = {
	                                accountIds: accountIds
	                            };
	                            request = {
	                                method: 'delete',
	                                url: "/accounts",
	                                data: req
	                            };
	                            return _context24.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context24.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all accounts linked to the member.
	         *
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getAccounts",
	        value: function getAccounts() {
	            var request;
	            return regeneratorRuntime.async(function getAccounts$(_context25) {
	                while (1) {
	                    switch (_context25.prev = _context25.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/accounts"
	                            };
	                            return _context25.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context25.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets an account.
	         *
	         * @param {string} accountId - account to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getAccount",
	        value: function getAccount(accountId) {
	            var request;
	            return regeneratorRuntime.async(function getAccount$(_context26) {
	                while (1) {
	                    switch (_context26.prev = _context26.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/accounts/" + accountId
	                            };
	                            return _context26.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context26.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets the default bank account.
	         *
	         * @return {Promise} response - the default bank account
	         */

	    }, {
	        key: "getDefaultAccount",
	        value: function getDefaultAccount() {
	            var request;
	            return regeneratorRuntime.async(function getDefaultAccount$(_context27) {
	                while (1) {
	                    switch (_context27.prev = _context27.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/members/" + this._memberId + "/default-account"
	                            };
	                            return _context27.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context27.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Sets the member's default bank account.
	         *
	         * @param {string} accountId - the bank account id
	         * @return {Promise} a promise
	         */

	    }, {
	        key: "setDefaultAccount",
	        value: function setDefaultAccount(accountId) {
	            var req, request;
	            return regeneratorRuntime.async(function setDefaultAccount$(_context28) {
	                while (1) {
	                    switch (_context28.prev = _context28.next) {
	                        case 0:
	                            req = { accountId: accountId };
	                            request = {
	                                method: 'put',
	                                url: "/members/" + this._memberId + "/default-account",
	                                data: req
	                            };
	                            return _context28.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context28.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Sets the name of an account.
	         *
	         * @param {string} accountId - account
	         * @param {string} name - new name
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "setAccountName",
	        value: function setAccountName(accountId, name) {
	            var request;
	            return regeneratorRuntime.async(function setAccountName$(_context29) {
	                while (1) {
	                    switch (_context29.prev = _context29.next) {
	                        case 0:
	                            request = {
	                                method: 'patch',
	                                url: "/accounts/" + accountId + "?name=" + name
	                            };
	                            return _context29.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context29.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets the balance of an account.
	         *
	         * @param {string} accountId - accountId
	         * @param {string} keyLevel - key level
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getBalance",
	        value: function getBalance(accountId, keyLevel) {
	            var request;
	            return regeneratorRuntime.async(function getBalance$(_context30) {
	                while (1) {
	                    switch (_context30.prev = _context30.next) {
	                        case 0:
	                            this.useKeyLevel(keyLevel);

	                            request = {
	                                method: 'get',
	                                url: "/accounts/" + accountId + "/balance"
	                            };
	                            return _context30.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context30.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets the balances of an array of accounts.
	         *
	         * @param {Array} accountIds - array of accountIds
	         * @param {string} keyLevel - key level
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getBalances",
	        value: function getBalances(accountIds, keyLevel) {
	            var url, request;
	            return regeneratorRuntime.async(function getBalances$(_context31) {
	                while (1) {
	                    switch (_context31.prev = _context31.next) {
	                        case 0:
	                            this.useKeyLevel(keyLevel);
	                            url = '/accounts/balance?' + accountIds.map(function (accountId) {
	                                return 'account_id=' + accountId;
	                            }).join('&');
	                            request = {
	                                method: 'get',
	                                url: url
	                            };
	                            return _context31.abrupt("return", this._instance(request));

	                        case 4:
	                        case "end":
	                            return _context31.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a transaction for an account, by its id.
	         *
	         * @param {string} accountId - account that initiated the transaction
	         * @param {string} transactionId - id of the transaction
	         * @param {string} keyLevel - key level
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTransaction",
	        value: function getTransaction(accountId, transactionId, keyLevel) {
	            var request;
	            return regeneratorRuntime.async(function getTransaction$(_context32) {
	                while (1) {
	                    switch (_context32.prev = _context32.next) {
	                        case 0:
	                            this.useKeyLevel(keyLevel);
	                            request = {
	                                method: 'get',
	                                url: "/accounts/" + accountId + "/transaction/" + transactionId
	                            };
	                            return _context32.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context32.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all transactions for an account.
	         *
	         * @param {string} accountId - id of the account
	         * @param {string} offset - where to start
	         * @param {Number} limit - how many to get
	         * @param {string} keyLevel - key level
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTransactions",
	        value: function getTransactions(accountId, offset, limit, keyLevel) {
	            var request;
	            return regeneratorRuntime.async(function getTransactions$(_context33) {
	                while (1) {
	                    switch (_context33.prev = _context33.next) {
	                        case 0:
	                            this.useKeyLevel(keyLevel);
	                            request = {
	                                method: 'get',
	                                url: "/accounts/" + accountId + "/transactions?offset=" + offset + "&limit=" + limit
	                            };
	                            return _context33.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context33.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Uploads a blob to the server.
	         *
	         * @param {string} ownerId - owner of the blob
	         * @param {string} type - MIME type
	         * @param {string} name - name of the file
	         * @param {Buffer} data - data in bytes
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "createBlob",
	        value: function createBlob(ownerId, type, name, data) {
	            var req, request;
	            return regeneratorRuntime.async(function createBlob$(_context34) {
	                while (1) {
	                    switch (_context34.prev = _context34.next) {
	                        case 0:
	                            req = {
	                                payload: {
	                                    ownerId: ownerId,
	                                    type: type,
	                                    name: name,
	                                    data: base64js.fromByteArray(data)
	                                }
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/blobs",
	                                data: req
	                            };
	                            return _context34.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context34.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a blob that is a attached to a token.
	         *
	         * @param {string} tokenId - id of the token
	         * @param {string} blobId - id of the blob
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTokenBlob",
	        value: function getTokenBlob(tokenId, blobId) {
	            var request;
	            return regeneratorRuntime.async(function getTokenBlob$(_context35) {
	                while (1) {
	                    switch (_context35.prev = _context35.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "tokens/" + tokenId + "/blobs/" + blobId
	                            };
	                            return _context35.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context35.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a blob from the server.
	         *
	         * @param {string} blobId - id of the blob
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getBlob",
	        value: function getBlob(blobId) {
	            var request;
	            return regeneratorRuntime.async(function getBlob$(_context36) {
	                while (1) {
	                    switch (_context36.prev = _context36.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/blobs/" + blobId
	                            };
	                            return _context36.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context36.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets info about a bank.
	         *
	         * @param {string} bankId - id of the bank to lookup
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getBankInfo",
	        value: function getBankInfo(bankId) {
	            var request;
	            return regeneratorRuntime.async(function getBankInfo$(_context37) {
	                while (1) {
	                    switch (_context37.prev = _context37.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/banks/" + bankId + "/info"
	                            };
	                            return _context37.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context37.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // Tokens
	        //

	        /**
	         * Stores a request for a token. Called by a merchant or a TPP that wants access from a user.
	         *
	         * @param {Object} tokenRequest - token request to store
	         * @return {Promise} response - response to the API call
	         */

	    }, {
	        key: "storeTokenRequest",
	        value: function storeTokenRequest(tokenRequest) {
	            var request;
	            return regeneratorRuntime.async(function storeTokenRequest$(_context38) {
	                while (1) {
	                    switch (_context38.prev = _context38.next) {
	                        case 0:
	                            request = {
	                                method: 'post',
	                                url: "/token-requests",
	                                data: tokenRequest
	                            };
	                            return _context38.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context38.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Creates a transfer token.
	         *
	         * @param {Object} payload - payload of the token
	         * @param {string} tokenRequestId - token request id
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "createTransferToken",
	        value: function createTransferToken(payload, tokenRequestId) {
	            var request;
	            return regeneratorRuntime.async(function createTransferToken$(_context39) {
	                while (1) {
	                    switch (_context39.prev = _context39.next) {
	                        case 0:
	                            request = {
	                                method: 'post',
	                                url: "/tokens?type=transfer",
	                                data: {
	                                    payload: payload,
	                                    tokenRequestId: tokenRequestId
	                                }
	                            };
	                            return _context39.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context39.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Creates an access token.
	         *
	         * @param {Object} payload - access token payload
	         * @param {string} tokenRequestId - token request id
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "createAccessToken",
	        value: function createAccessToken(payload, tokenRequestId) {
	            var request;
	            return regeneratorRuntime.async(function createAccessToken$(_context40) {
	                while (1) {
	                    switch (_context40.prev = _context40.next) {
	                        case 0:
	                            request = {
	                                method: 'post',
	                                url: "/tokens?type=access",
	                                data: {
	                                    payload: payload,
	                                    tokenRequestId: tokenRequestId
	                                }
	                            };
	                            return _context40.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context40.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Replaces an access token with one with updated resources.
	         *
	         * @param {Object} tokenToCancel - access token to replace
	         * @param {Array} newResources - new resources
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "replaceToken",
	        value: function replaceToken(tokenToCancel, newResources) {
	            var cancelTokenId, cancelReq, createReq, request;
	            return regeneratorRuntime.async(function replaceToken$(_context41) {
	                while (1) {
	                    switch (_context41.prev = _context41.next) {
	                        case 0:
	                            cancelTokenId = tokenToCancel.id;
	                            _context41.next = 3;
	                            return regeneratorRuntime.awrap(this._tokenOperationRequest(tokenToCancel, 'cancelled'));

	                        case 3:
	                            cancelReq = _context41.sent;
	                            createReq = {
	                                payload: {
	                                    from: {
	                                        id: this._memberId
	                                    },
	                                    to: tokenToCancel.payload.to,
	                                    access: {
	                                        resources: newResources
	                                    },
	                                    issuer: tokenToCancel.payload.issuer,
	                                    version: _config2.default.accessTokenVersion,
	                                    refId: _Util2.default.generateNonce()
	                                }
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/tokens/" + cancelTokenId + "/replace",
	                                data: {
	                                    cancel_token: cancelReq,
	                                    create_token: createReq
	                                }
	                            };
	                            return _context41.abrupt("return", this._instance(request));

	                        case 7:
	                        case "end":
	                            return _context41.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Replaces an access token with one with updated resources, and endorses it.
	         *
	         * @param {Object} tokenToCancel - access token to replace
	         * @param {Array} newResources - new resources
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "replaceAndEndorseToken",
	        value: function replaceAndEndorseToken(tokenToCancel, newResources) {
	            var cancelTokenId, cancelReq, payload, createReq, request;
	            return regeneratorRuntime.async(function replaceAndEndorseToken$(_context42) {
	                while (1) {
	                    switch (_context42.prev = _context42.next) {
	                        case 0:
	                            cancelTokenId = tokenToCancel.id;
	                            _context42.next = 3;
	                            return regeneratorRuntime.awrap(this._tokenOperationRequest(tokenToCancel, 'cancelled'));

	                        case 3:
	                            cancelReq = _context42.sent;
	                            payload = {
	                                from: {
	                                    id: this._memberId
	                                },
	                                to: tokenToCancel.payload.to,
	                                access: {
	                                    resources: newResources
	                                },
	                                issuer: tokenToCancel.payload.issuer,
	                                version: _config2.default.accessTokenVersion,
	                                refId: _Util2.default.generateNonce()
	                            };
	                            _context42.t0 = payload;
	                            _context42.next = 8;
	                            return regeneratorRuntime.awrap(this._tokenOperationSignature(payload, 'endorsed'));

	                        case 8:
	                            _context42.t1 = _context42.sent;
	                            createReq = {
	                                payload: _context42.t0,
	                                payload_signature: _context42.t1
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/tokens/" + cancelTokenId + "/replace",
	                                data: {
	                                    cancel_token: cancelReq,
	                                    create_token: createReq
	                                }
	                            };
	                            return _context42.abrupt("return", this._instance(request));

	                        case 12:
	                        case "end":
	                            return _context42.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Endorses a token.
	         *
	         * @param {Object} token - token to endorse
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "endorseToken",
	        value: function endorseToken(token) {
	            return regeneratorRuntime.async(function endorseToken$(_context43) {
	                while (1) {
	                    switch (_context43.prev = _context43.next) {
	                        case 0:
	                            return _context43.abrupt("return", this._tokenOperation(token, 'endorse', 'endorsed'));

	                        case 1:
	                        case "end":
	                            return _context43.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Cancels a token.
	         *
	         * @param {Object} token - token to cancel
	         * @param {bool} blocking - creates a blocking request
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "cancelToken",
	        value: function cancelToken(token, blocking) {
	            return regeneratorRuntime.async(function cancelToken$(_context44) {
	                while (1) {
	                    switch (_context44.prev = _context44.next) {
	                        case 0:
	                            return _context44.abrupt("return", this._tokenOperation(token, 'cancel', 'cancelled', blocking));

	                        case 1:
	                        case "end":
	                            return _context44.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Redeems a transfer token.
	         *
	         * @param {Object} transferToken - token to redeem
	         * @param {Number} amount - amount to charge
	         * @param {string} currency - currency to charge
	         * @param {string} description - description of the transfer
	         * @param {Array} destinations - destinations money should go to
	         * @param {string} refId - reference Id to attach to the transfer
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "redeemToken",
	        value: function redeemToken(transferToken, amount, currency, description, destinations, refId) {
	            var payload, signer, req, request;
	            return regeneratorRuntime.async(function redeemToken$(_context45) {
	                while (1) {
	                    switch (_context45.prev = _context45.next) {
	                        case 0:
	                            if (!refId) {
	                                refId = _Util2.default.generateNonce();
	                            }
	                            payload = {
	                                refId: refId,
	                                tokenId: transferToken.id,
	                                amount: {
	                                    value: amount.toString(),
	                                    currency: currency
	                                }
	                            };


	                            if (description) {
	                                payload.description = description;
	                            }

	                            if (destinations !== undefined && destinations.length > 0) {
	                                payload.destinations = destinations;
	                            }

	                            _context45.next = 6;
	                            return regeneratorRuntime.awrap(this.getSigner(_config2.default.KeyLevel.LOW));

	                        case 6:
	                            signer = _context45.sent;
	                            _context45.t0 = payload;
	                            _context45.t1 = this._memberId;
	                            _context45.t2 = signer.getKeyId();
	                            _context45.next = 12;
	                            return regeneratorRuntime.awrap(signer.signJson(payload));

	                        case 12:
	                            _context45.t3 = _context45.sent;
	                            _context45.t4 = {
	                                memberId: _context45.t1,
	                                keyId: _context45.t2,
	                                signature: _context45.t3
	                            };
	                            req = {
	                                payload: _context45.t0,
	                                payloadSignature: _context45.t4
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/transfers",
	                                data: req
	                            };
	                            return _context45.abrupt("return", this._instance(request));

	                        case 17:
	                        case "end":
	                            return _context45.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets a token by its id.
	         *
	         * @param {string} tokenId - id of the token to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getToken",
	        value: function getToken(tokenId) {
	            var request;
	            return regeneratorRuntime.async(function getToken$(_context46) {
	                while (1) {
	                    switch (_context46.prev = _context46.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/tokens/" + tokenId
	                            };
	                            return _context46.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context46.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Looks up a existing access token where the calling member is the grantor and given member is
	         * the grantee.
	         *
	         * @param {string} toMemberId - beneficiary of the active access token
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getActiveAccessToken",
	        value: function getActiveAccessToken(toMemberId) {
	            var request;
	            return regeneratorRuntime.async(function getActiveAccessToken$(_context47) {
	                while (1) {
	                    switch (_context47.prev = _context47.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/tokens/active-access-token/" + toMemberId
	                            };
	                            return _context47.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context47.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all tokens of the member, of a certain type.
	         *
	         * @param {string} type - type of tokens to get
	         * @param {string} offset - where to start looking
	         * @param {Number} limit - how many to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTokens",
	        value: function getTokens(type, offset, limit) {
	            var request;
	            return regeneratorRuntime.async(function getTokens$(_context48) {
	                while (1) {
	                    switch (_context48.prev = _context48.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/tokens?type=" + type + "&offset=" + offset + "&limit=" + limit
	                            };
	                            return _context48.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context48.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }, {
	        key: "_tokenOperation",
	        value: function _tokenOperation(token, operation, suffix, blocking) {
	            var tokenId, request;
	            return regeneratorRuntime.async(function _tokenOperation$(_context49) {
	                while (1) {
	                    switch (_context49.prev = _context49.next) {
	                        case 0:
	                            tokenId = token.id;
	                            _context49.t0 = "/tokens/" + tokenId + "/" + operation;
	                            _context49.next = 4;
	                            return regeneratorRuntime.awrap(this._tokenOperationRequest(token, suffix));

	                        case 4:
	                            _context49.t1 = _context49.sent;
	                            request = {
	                                method: 'put',
	                                url: _context49.t0,
	                                data: _context49.t1
	                            };

	                            if (blocking) request.adapter = BlockingAdapter;
	                            return _context49.abrupt("return", this._instance(request));

	                        case 8:
	                        case "end":
	                            return _context49.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }, {
	        key: "_tokenOperationRequest",
	        value: function _tokenOperationRequest(token, suffix) {
	            return regeneratorRuntime.async(function _tokenOperationRequest$(_context50) {
	                while (1) {
	                    switch (_context50.prev = _context50.next) {
	                        case 0:
	                            _context50.t0 = token.id;
	                            _context50.next = 3;
	                            return regeneratorRuntime.awrap(this._tokenOperationSignature(token.payload, suffix));

	                        case 3:
	                            _context50.t1 = _context50.sent;
	                            return _context50.abrupt("return", {
	                                tokenId: _context50.t0,
	                                signature: _context50.t1
	                            });

	                        case 5:
	                        case "end":
	                            return _context50.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }, {
	        key: "_tokenOperationSignature",
	        value: function _tokenOperationSignature(tokenPayload, suffix) {
	            var payload, signer;
	            return regeneratorRuntime.async(function _tokenOperationSignature$(_context51) {
	                while (1) {
	                    switch (_context51.prev = _context51.next) {
	                        case 0:
	                            payload = stringify(tokenPayload) + ("." + suffix);
	                            _context51.next = 3;
	                            return regeneratorRuntime.awrap(this.getSigner(_config2.default.KeyLevel.STANDARD));

	                        case 3:
	                            signer = _context51.sent;
	                            _context51.t0 = this._memberId;
	                            _context51.t1 = signer.getKeyId();
	                            _context51.next = 8;
	                            return regeneratorRuntime.awrap(signer.sign(payload));

	                        case 8:
	                            _context51.t2 = _context51.sent;
	                            return _context51.abrupt("return", {
	                                memberId: _context51.t0,
	                                keyId: _context51.t1,
	                                signature: _context51.t2
	                            });

	                        case 10:
	                        case "end":
	                            return _context51.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // Transfers
	        //

	        /**
	         * Gets a transfer by id.
	         *
	         * @param {string} transferId - id of the transfer
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTransfer",
	        value: function getTransfer(transferId) {
	            var request;
	            return regeneratorRuntime.async(function getTransfer$(_context52) {
	                while (1) {
	                    switch (_context52.prev = _context52.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/transfers/" + transferId
	                            };
	                            return _context52.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context52.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets all transfers on a token.
	         *
	         * @param {string} tokenId - id of the token
	         * @param {string} offset - where to start
	         * @param {Number} limit - how many to get
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTransfers",
	        value: function getTransfers(tokenId, offset, limit) {
	            var request;
	            return regeneratorRuntime.async(function getTransfers$(_context53) {
	                while (1) {
	                    switch (_context53.prev = _context53.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/transfers?tokenId=" + tokenId + "&offset=" + offset + "&limit=" + limit
	                            };
	                            return _context53.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context53.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // Directory
	        //

	        /**
	         * Adds a key to the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Object} key - key to add
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "approveKey",
	        value: function approveKey(prevHash, key) {
	            var update;
	            return regeneratorRuntime.async(function approveKey$(_context54) {
	                while (1) {
	                    switch (_context54.prev = _context54.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: [{
	                                    addKey: {
	                                        key: _extends({
	                                            id: key.id,
	                                            publicKey: _Crypto2.default.strKey(key.publicKey),
	                                            level: key.level,
	                                            algorithm: key.algorithm
	                                        }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs.toString() })
	                                    }
	                                }]
	                            };
	                            return _context54.abrupt("return", this._memberUpdate(update, prevHash));

	                        case 2:
	                        case "end":
	                            return _context54.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Adds keys to the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Array} keys - keys to add
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "approveKeys",
	        value: function approveKeys(prevHash, keys) {
	            var update;
	            return regeneratorRuntime.async(function approveKeys$(_context55) {
	                while (1) {
	                    switch (_context55.prev = _context55.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: keys.map(function (key) {
	                                    return {
	                                        addKey: {
	                                            key: _extends({
	                                                id: key.id,
	                                                publicKey: _Crypto2.default.strKey(key.publicKey),
	                                                level: key.level,
	                                                algorithm: key.algorithm
	                                            }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs.toString() })
	                                        }
	                                    };
	                                })
	                            };
	                            return _context55.abrupt("return", this._memberUpdate(update, prevHash));

	                        case 2:
	                        case "end":
	                            return _context55.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Removes a key from the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {string} keyId - keyId to remove
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "removeKey",
	        value: function removeKey(prevHash, keyId) {
	            var update;
	            return regeneratorRuntime.async(function removeKey$(_context56) {
	                while (1) {
	                    switch (_context56.prev = _context56.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: [{
	                                    removeKey: {
	                                        keyId: keyId
	                                    }
	                                }]
	                            };
	                            return _context56.abrupt("return", this._memberUpdate(update, prevHash));

	                        case 2:
	                        case "end":
	                            return _context56.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Removes keys from the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Array} keyIds - keys to remove
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "removeKeys",
	        value: function removeKeys(prevHash, keyIds) {
	            var update;
	            return regeneratorRuntime.async(function removeKeys$(_context57) {
	                while (1) {
	                    switch (_context57.prev = _context57.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: keyIds.map(function (keyId) {
	                                    return {
	                                        removeKey: {
	                                            keyId: keyId
	                                        }
	                                    };
	                                })
	                            };
	                            return _context57.abrupt("return", this._memberUpdate(update, prevHash));

	                        case 2:
	                        case "end":
	                            return _context57.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Adds an alias to the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Object} alias - alias to add
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "addAlias",
	        value: function addAlias(prevHash, alias, realm) {
	            return regeneratorRuntime.async(function addAlias$(_context58) {
	                while (1) {
	                    switch (_context58.prev = _context58.next) {
	                        case 0:
	                            return _context58.abrupt("return", this.addAliases(prevHash, [alias], realm));

	                        case 1:
	                        case "end":
	                            return _context58.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets logged-in member's aliases, verified or not.
	         *
	         * @return {Object} response object; has aliases, unverifiedAliases
	         */

	    }, {
	        key: "getAliases",
	        value: function getAliases() {
	            var request;
	            return regeneratorRuntime.async(function getAliases$(_context59) {
	                while (1) {
	                    switch (_context59.prev = _context59.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: '/aliases'
	                            };
	                            return _context59.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context59.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Get default recovery agent.
	         * @return {Object} GetDefaultAgentResponse proto buffer
	         */

	    }, {
	        key: "getDefaultRecoveryAgent",
	        value: function getDefaultRecoveryAgent() {
	            var request;
	            return regeneratorRuntime.async(function getDefaultRecoveryAgent$(_context60) {
	                while (1) {
	                    switch (_context60.prev = _context60.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: '/recovery/defaults/agent'
	                            };
	                            return _context60.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context60.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Set member's recovery rule.
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Object} rule - RecoveryRule proto buffer specifying behavior.
	         * @return {Object} UpdateMemberResponse proto buffer
	         */

	    }, {
	        key: "addRecoveryRule",
	        value: function addRecoveryRule(prevHash, rule) {
	            var update;
	            return regeneratorRuntime.async(function addRecoveryRule$(_context61) {
	                while (1) {
	                    switch (_context61.prev = _context61.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: [{
	                                    recoveryRules: rule
	                                }]
	                            };
	                            return _context61.abrupt("return", this._memberUpdate(update, prevHash));

	                        case 2:
	                        case "end":
	                            return _context61.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Adds aliases to the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Array} aliases - aliases to add
	         * @param {string} realm - (optional) realm of the aliases
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "addAliases",
	        value: function addAliases(prevHash, aliases, realm) {
	            var update, metadata;
	            return regeneratorRuntime.async(function addAliases$(_context62) {
	                while (1) {
	                    switch (_context62.prev = _context62.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: aliases.map(function (alias) {
	                                    return {
	                                        addAlias: {
	                                            aliasHash: _Util2.default.hashAndSerializeAlias(alias),
	                                            realm: realm
	                                        }
	                                    };
	                                })
	                            };
	                            metadata = aliases.map(function (alias) {
	                                return {
	                                    addAliasMetadata: {
	                                        aliasHash: _Util2.default.hashAndSerializeAlias(alias),
	                                        alias: alias,
	                                        realm: realm
	                                    }
	                                };
	                            });
	                            return _context62.abrupt("return", this._memberUpdate(update, prevHash, metadata));

	                        case 3:
	                        case "end":
	                            return _context62.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Removes an alias from the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Object} alias - alias to remove
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "removeAlias",
	        value: function removeAlias(prevHash, alias) {
	            return regeneratorRuntime.async(function removeAlias$(_context63) {
	                while (1) {
	                    switch (_context63.prev = _context63.next) {
	                        case 0:
	                            return _context63.abrupt("return", this.removeAliases(prevHash, [alias]));

	                        case 1:
	                        case "end":
	                            return _context63.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Removes aliases from the member.
	         *
	         * @param {string} prevHash - hash of the previous directory entry.
	         * @param {Array} aliases - aliases to remove
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "removeAliases",
	        value: function removeAliases(prevHash, aliases) {
	            var update;
	            return regeneratorRuntime.async(function removeAliases$(_context64) {
	                while (1) {
	                    switch (_context64.prev = _context64.next) {
	                        case 0:
	                            update = {
	                                memberId: this._memberId,
	                                operations: aliases.map(function (alias) {
	                                    return {
	                                        removeAlias: {
	                                            aliasHash: _Util2.default.hashAndSerializeAlias(alias)
	                                        }
	                                    };
	                                })
	                            };
	                            return _context64.abrupt("return", this._memberUpdate(update, prevHash));

	                        case 2:
	                        case "end":
	                            return _context64.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }, {
	        key: "_memberUpdate",
	        value: function _memberUpdate(update, prevHash, metadata) {
	            var signer, req, request;
	            return regeneratorRuntime.async(function _memberUpdate$(_context65) {
	                while (1) {
	                    switch (_context65.prev = _context65.next) {
	                        case 0:
	                            if (prevHash !== '') {
	                                update.prevHash = prevHash;
	                            }
	                            if (typeof metadata === "undefined") {
	                                metadata = [];
	                            }

	                            _context65.next = 4;
	                            return regeneratorRuntime.awrap(this.getSigner(_config2.default.KeyLevel.PRIVILEGED));

	                        case 4:
	                            signer = _context65.sent;
	                            _context65.t0 = update;
	                            _context65.t1 = this._memberId;
	                            _context65.t2 = signer.getKeyId();
	                            _context65.next = 10;
	                            return regeneratorRuntime.awrap(signer.signJson(update));

	                        case 10:
	                            _context65.t3 = _context65.sent;
	                            _context65.t4 = {
	                                memberId: _context65.t1,
	                                keyId: _context65.t2,
	                                signature: _context65.t3
	                            };
	                            _context65.t5 = metadata;
	                            req = {
	                                update: _context65.t0,
	                                updateSignature: _context65.t4,
	                                metadata: _context65.t5
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/members/" + this._memberId + "/updates",
	                                data: req
	                            };
	                            return _context65.abrupt("return", this._instance(request));

	                        case 16:
	                        case "end":
	                            return _context65.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Sign with a Token signature a token request state payload.
	         *
	         * @param {string} tokenId - token id
	         * @param {string} state - url state
	         * @return {Object} response - response to the api call
	         */

	    }, {
	        key: "signTokenRequestState",
	        value: function signTokenRequestState(tokenId, state) {
	            var req, request;
	            return regeneratorRuntime.async(function signTokenRequestState$(_context66) {
	                while (1) {
	                    switch (_context66.prev = _context66.next) {
	                        case 0:
	                            req = {
	                                payload: {
	                                    tokenId: tokenId,
	                                    state: state
	                                }
	                            };
	                            request = {
	                                method: 'put',
	                                url: "/sign-token-request-state",
	                                data: req
	                            };
	                            return _context66.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context66.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Deletes the member.
	         *
	         * @return {Object} response - response to the api call
	         */

	    }, {
	        key: "deleteMember",
	        value: function deleteMember() {
	            var request;
	            return regeneratorRuntime.async(function deleteMember$(_context67) {
	                while (1) {
	                    switch (_context67.prev = _context67.next) {
	                        case 0:
	                            this.useKeyLevel(_config2.default.KeyLevel.PRIVILEGED);
	                            request = {
	                                method: 'delete',
	                                url: "/members"
	                            };
	                            return _context67.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context67.stop();
	                    }
	                }
	            }, null, this);
	        }

	        //
	        // Test
	        //

	        /**
	         * Creates a test bank account.
	         *
	         * @param {Number} balance - balance to put in the account
	         * @param {string} currency - currency in the account
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "createTestBankAccount",
	        value: function createTestBankAccount(balance, currency) {
	            var req, request;
	            return regeneratorRuntime.async(function createTestBankAccount$(_context68) {
	                while (1) {
	                    switch (_context68.prev = _context68.next) {
	                        case 0:
	                            req = {
	                                balance: {
	                                    currency: currency,
	                                    value: balance
	                                }
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/test/create-account",
	                                data: req
	                            };
	                            return _context68.abrupt("return", this._instance(request));

	                        case 3:
	                        case "end":
	                            return _context68.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets test bank notification.
	         *
	         * @param {string} subscriberId - id of subscriber
	         * @param {string} notificationId - id of notification
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTestBankNotification",
	        value: function getTestBankNotification(subscriberId, notificationId) {
	            var request;
	            return regeneratorRuntime.async(function getTestBankNotification$(_context69) {
	                while (1) {
	                    switch (_context69.prev = _context69.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/test/subscribers/" + subscriberId + "/notifications/" + notificationId
	                            };
	                            return _context69.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context69.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Gets test bank notifications.
	         *
	         * @param {string} subscriberId - id of subscriber
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTestBankNotifications",
	        value: function getTestBankNotifications(subscriberId) {
	            var request;
	            return regeneratorRuntime.async(function getTestBankNotifications$(_context70) {
	                while (1) {
	                    switch (_context70.prev = _context70.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/test/subscribers/" + subscriberId + "/notifications"
	                            };
	                            return _context70.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context70.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return AuthHttpClient;
	}();

	exports.default = AuthHttpClient;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var stringify = __webpack_require__(5);

	/**
	 * Handles the addition of the http headers (with signature) to the request
	 */
	var AuthHeader = function () {
	    /**
	     * Creates an AuthHeader object with set url and signer
	     *
	     * @param {string} baseUrl - url to send requests to (gateway)
	     * @param {Object} client - client, to get the signer
	     */
	    function AuthHeader(baseUrl, client) {
	        _classCallCheck(this, AuthHeader);

	        this._baseUrl = baseUrl;
	        this._client = client;
	    }

	    /**
	     * Adds an authorization header to the request. This takes into account the url,
	     * payload of the request (with timestamp), to generate a message and signature.
	     * All of it goes into the Authorization http header.
	     *
	     * @param {string} memberId - memberId making the request
	     * @param {Object} request - request
	     * @param {AuthContext} context - auth context for access token redemption
	     */


	    _createClass(AuthHeader, [{
	        key: 'addAuthorizationHeader',
	        value: function addAuthorizationHeader(memberId, request, context) {
	            var now, uriPath, payload, signer, signature, header;
	            return regeneratorRuntime.async(function addAuthorizationHeader$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            now = new Date().getTime();

	                            // Parses out the base uri

	                            uriPath = request.url.replace(this._baseUrl, '');

	                            // Makes sure the uri is formatted correctly

	                            uriPath = uriPath.substring(0, 1) === '/' ? uriPath : uriPath + '/';
	                            uriPath = uriPath.substring(uriPath.length - 1) === '/' ? uriPath.substring(0, uriPath.length - 1) : uriPath;

	                            // Path should not include query parameters
	                            if (uriPath.indexOf("?") >= 0) {
	                                uriPath = uriPath.substring(0, uriPath.indexOf("?"));
	                            }

	                            // Creates the payload from the request info
	                            payload = {
	                                method: request.method.toUpperCase(),
	                                uriHost: this._baseUrl.replace('http://', '').replace('https://', ''),
	                                uriPath: uriPath,
	                                createdAtMs: now.toString()
	                            };


	                            if (request.data !== undefined && request.data !== '') {
	                                payload.requestBody = stringify(request.data);
	                            }

	                            // Signs the query string as well, if it exists
	                            if (request.url.indexOf("?") !== -1) {
	                                payload.queryString = request.url.substring(request.url.indexOf("?") + 1);
	                            }

	                            // Creates the signer object
	                            _context.next = 10;
	                            return regeneratorRuntime.awrap(this._client.getSigner(AuthHeader._keyLevel(context)));

	                        case 10:
	                            signer = _context.sent;
	                            _context.next = 13;
	                            return regeneratorRuntime.awrap(signer.signJson(payload));

	                        case 13:
	                            signature = _context.sent;


	                            // Creates the authorization header, ands adds it to the request
	                            header = _config2.default.signatureScheme + ' ' + 'member-id=' + memberId + ',' + 'key-id=' + signer.getKeyId() + ',' + 'signature=' + signature + ',' + 'created-at-ms=' + now + AuthHeader._onBehalfOfHeader(context) + AuthHeader._customerInitiated(context);


	                            request.headers = {
	                                Authorization: header
	                            };

	                        case 16:
	                        case 'end':
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }], [{
	        key: '_onBehalfOfHeader',
	        value: function _onBehalfOfHeader(context) {
	            if (context !== undefined && context.onBehalfOf !== undefined && context.onBehalfOf !== '') {
	                return ',on-behalf-of=' + context.onBehalfOf;
	            }
	            return '';
	        }
	    }, {
	        key: '_keyLevel',
	        value: function _keyLevel(context) {
	            // if we specified that this request should use a keyLevel > LOW, we notice that here
	            // (and re-set the keyLevel for the next request)
	            if (context !== undefined) {
	                var level = context.keyLevel;
	                context.keyLevel = _config2.default.KeyLevel.LOW;
	                return level;
	            }
	            return _config2.default.KeyLevel.LOW;
	        }
	    }, {
	        key: '_customerInitiated',
	        value: function _customerInitiated(context) {
	            // if the customer initiated request flag is set to true,
	            // we add it to the header, and reset the flag.
	            if (context && context.customerInitiated) {
	                context.customerInitiated = false;
	                return ',customer-initiated=true';
	            }
	            return '';
	        }
	    }]);

	    return AuthHeader;
	}();

	exports.default = AuthHeader;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	module.exports = {
		"signatureScheme": "Token-Ed25519-SHA512",
		"urls": {
			"local": "http://localhost:8000",
			"dev": "https://api.dev.token.io",
			"stg": "https://api.stg.token.io",
			"sandbox": "https://api.sandbox.token.io",
			"int": "https://api.int.token.io",
			"prd": "https://api.token.io"
		},
		"webAppUrls": {
			"local": "http://localhost:5000",
			"dev": "https://web-app.dev.token.io",
			"stg": "https://web-app.stg.token.io",
			"sandbox": "https://web-app.sandbox.token.io",
			"int": "https://web-app.int.token.io",
			"prd": "https://web-app.token.io"
		},
		"transferTokenVersion": "1.0",
		"accessTokenVersion": "1.0",
		"defaultCurrency": "EUR",
		"decimalPrecision": 4,
		"corsDomainSuffix": ".token.io",
		"KeyLevel": {
			"PRIVILEGED": "PRIVILEGED",
			"STANDARD": "STANDARD",
			"LOW": "LOW"
		},
		"lowKeyExpiration": 1209600000,
		"devKey": {
			"local": "f3982819-5d8d-4123-9601-886df2780f42",
			"dev": "f3982819-5d8d-4123-9601-886df2780f42",
			"stg": "f3982819-5d8d-4123-9601-886df2780f42",
			"sandbox": "f3982819-5d8d-4123-9601-886df2780f42",
			"int": "f3982819-5d8d-4123-9601-886df2780f42",
			"prd": "f3982819-5d8d-4123-9601-886df2780f42"
		}
	};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Handles the auth context when using access tokens.
	 */
	var AuthContext = function () {
	    /**
	     * Creates an AuthContext object
	     */
	    function AuthContext() {
	        _classCallCheck(this, AuthContext);

	        this._onBehalfOf = undefined;
	        this._keyLevel = _config2.default.KeyLevel.LOW;
	        this._customerInitiated = false;
	    }

	    /**
	     * Sets the auth context to act on behalf of another member
	     *
	     * @param {string} onBehalfOf - accessTokenId to use
	     */


	    _createClass(AuthContext, [{
	        key: "onBehalfOf",
	        set: function set(onBehalfOf) {
	            this._onBehalfOf = onBehalfOf;
	        }

	        /**
	        * Sets the key level to be used to sign the auth header
	        *
	        * @param {string} keyLevel - key Level to use
	        */
	        ,


	        /**
	         * Gets the currently active memberId
	         *
	         * @return {string} onBehalfOf - accessTokenId being used
	         */
	        get: function get() {
	            return this._onBehalfOf;
	        }

	        /**
	         * Gets the key level
	         *
	         * @return {string} keyLevel - key level being used
	         */

	    }, {
	        key: "keyLevel",
	        set: function set(keyLevel) {
	            this._keyLevel = keyLevel === undefined ? _config2.default.KeyLevel.LOW : keyLevel;
	        }

	        /**
	         * Sets the auth context to indicate that the next api call
	         * would have been initiated by the customer.
	         *
	         * @param {boolean} flag - true if request initiated by customer
	         */
	        ,
	        get: function get() {
	            return this._keyLevel;
	        }

	        /**
	         * Gets the customer initiated request flag.
	         *
	         * @return {boolean} flag - true if request initiated by customer
	         */

	    }, {
	        key: "customerInitiated",
	        set: function set(flag) {
	            this._customerInitiated = flag;
	        },
	        get: function get() {
	            return this._customerInitiated;
	        }
	    }]);

	    return AuthContext;
	}();

	exports.default = AuthContext;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * RPC error handler that facilitates handling cross-cutting API errors. Converts generic
	 * StatusRuntimeException instances into specific Exception types to be handled by the callers.
	 *
	 * The globalRpcErrorCallback is invoked with a {name, message} error object any time
	 * a custom RPC error occurs.
	 */
	var ErrorHandler = function () {
	    /**
	     * Creates the error handler instance.
	     *
	     * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
	     * call error. For example: SDK version mismatch
	     */
	    function ErrorHandler(globalRpcErrorCallback) {
	        _classCallCheck(this, ErrorHandler);

	        this._globalRpcErrorCallback = globalRpcErrorCallback;
	    }

	    /**
	     * Handles RPC error and calls the globalRpcErrorCallback.
	     *
	     * @param {object} error - error to handle
	     * @return {object} error - original RPC error
	     */


	    _createClass(ErrorHandler, [{
	        key: 'handleError',
	        value: function handleError(error) {
	            if (error.response && error.response.headers) {
	                var tokenError = error.response.headers['token-error'];
	                var tokenErrorDetails = error.response.headers['token-error-details'];

	                if (tokenErrorDetails) {
	                    // Log optional error details to ease up troubleshooting.
	                    // Available only in non-prod deployments.
	                    console.log("Error details: ", tokenErrorDetails);
	                }

	                if (this._globalRpcErrorCallback) {
	                    var name = tokenError ? tokenError : 'UNKNOWN';
	                    var mappedError = {
	                        name: name,
	                        message: error.response.data
	                    };
	                    this._globalRpcErrorCallback(mappedError);
	                    return mappedError;
	                }
	            }
	            return error;
	        }
	    }]);

	    return ErrorHandler;
	}();

	exports.default = ErrorHandler;

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Class to add sdk developer key.
	 */
	var DeveloperHeader = function () {
	    /**
	     * Initializes the developer header with the developer key.
	     *
	     * @param {string} developerKey - the developer key, by default empty
	     */
	    function DeveloperHeader() {
	        var developerKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

	        _classCallCheck(this, DeveloperHeader);

	        this._developerKey = developerKey;
	    }

	    /**
	     * Adds the developer key to the request config if not empty.
	     *
	     * @param {Object} config - config of the request
	     */


	    _createClass(DeveloperHeader, [{
	        key: "addDeveloperHeader",
	        value: function addDeveloperHeader(config) {
	            if (this._developerKey === "") {
	                throw new ReferenceError("Please provide a developer key." + " Contact Token for more details.");
	            } else {
	                config.headers['token-dev-key'] = this._developerKey;
	            }
	        }
	    }]);

	    return DeveloperHeader;
	}();

	exports.default = DeveloperHeader;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Class to add sdk version and type.
	 */
	var VersionHeader = function () {
	  function VersionHeader() {
	    _classCallCheck(this, VersionHeader);
	  }

	  _createClass(VersionHeader, [{
	    key: 'addVersionHeader',

	    /**
	     * Adds the sdk type and version to the request config.
	     *
	     * @param {Object} config - config of the request
	     */
	    value: function addVersionHeader(config) {
	      config.headers['token-sdk'] = 'js';
	      config.headers['token-sdk-version'] = ("1.5.19");
	    }
	  }]);

	  return VersionHeader;
	}();

	exports.default = VersionHeader;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = require("base64-js");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	module.exports = require("axios");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(38);
	var buildURL = __webpack_require__(40);
	var isURLSameOrigin = __webpack_require__(41);
	var btoa = typeof window !== 'undefined' && window.btoa || __webpack_require__(42);

	/**
	 * Axios adapter to create a blocking XMLHttpRequest
	 * @param  {Object} config  configuration for the request
	 * @return {Promise}        response - response object with a 'dispatchRequest' function
	 *                          to trigger the blocking request
	 */
	module.exports = function BlockingAdapter(config) {
	  if (typeof XMLHttpRequest === 'undefined' && typeof process !== 'undefined') {
	    // for node ignore request
	    return new Promise(function ignoreRequest(resolve) {
	      resolve({
	        data: {
	          dispatchRequest: function dispatchRequest() {
	            // Send the request
	            throw new Error('BlockingAdapter does not support node.js');
	          }
	        }
	      });
	    });
	  }
	  var requestData = config.data;
	  var requestHeaders = config.headers;

	  if (utils.isFormData(requestData)) {
	    delete requestHeaders['Content-Type']; // Let the browser set it
	  }

	  var request = new XMLHttpRequest();

	  // For IE 8/9 CORS support
	  // Only supports POST and GET calls and doesn't returns the response headers.
	  // DON'T do this for testing field_size/c XMLHttpRequest is mocked, not XDomainRequest.
	  if (typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
	    request = new window.XDomainRequest();
	  }

	  // HTTP basic authentication
	  if (config.auth) {
	    var username = config.auth.username || '';
	    var password = config.auth.password || '';
	    requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	  }

	  request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), false);

	  // Add xsrf header
	  // This is only done if running in a standard browser environment.
	  // Specifically not if we're in a web worker, or react-native.
	  if (utils.isStandardBrowserEnv()) {
	    var cookies = __webpack_require__(43);

	    // Add xsrf header
	    var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

	    if (xsrfValue) {
	      requestHeaders[config.xsrfHeaderName] = xsrfValue;
	    }
	  }

	  // Add headers to the request
	  if ('setRequestHeader' in request) {
	    utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	      if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	        // Remove Content-Type if data is undefined
	        delete requestHeaders[key];
	      } else {
	        // Otherwise add header to the request
	        request.setRequestHeader(key, val);
	      }
	    });
	  }

	  // Add withCredentials to request if needed
	  if (config.withCredentials) {
	    request.withCredentials = true;
	  }

	  // Add responseType to request if needed
	  if (config.responseType) {
	    try {
	      request.responseType = config.responseType;
	    } catch (e) {
	      if (request.responseType !== 'json') {
	        throw e;
	      }
	    }
	  }

	  if (requestData === undefined) {
	    requestData = null;
	  }

	  // Return a promise with 'dispatchRequest' function to execute the synchronous call
	  return new Promise(function dispatchXhrRequest(resolve) {
	    resolve({
	      data: {
	        dispatchRequest: function dispatchRequest() {
	          // Send the request
	          var res = request.send(requestData);
	          return res;
	        }
	      }
	    });
	  });
	};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var bind = __webpack_require__(39);

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined' &&
	    typeof document.createElement === 'function'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object field_size.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(38);

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }

	      if (!utils.isArray(val)) {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(38);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;

	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;

	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }

	      urlParsingNode.setAttribute('href', href);

	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }

	    originURL = resolveURL(window.location.href);

	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	'use strict';

	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';

	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}

	module.exports = btoa;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(38);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));

	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }

	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }

	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }

	        if (secure === true) {
	          cookie.push('secure');
	        }

	        document.cookie = cookie.join('; ');
	      },

	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },

	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	var _Crypto = __webpack_require__(4);

	var _Crypto2 = _interopRequireDefault(_Crypto);

	var _ErrorHandler = __webpack_require__(32);

	var _ErrorHandler2 = _interopRequireDefault(_ErrorHandler);

	var _DeveloperHeader = __webpack_require__(33);

	var _DeveloperHeader2 = _interopRequireDefault(_DeveloperHeader);

	var _VersionHeader = __webpack_require__(34);

	var _VersionHeader2 = _interopRequireDefault(_VersionHeader);

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var axios = __webpack_require__(36);

	/**
	 * Client to make unauthenticated requests to the Token gateway.
	 */

	var HttpClient = function () {
	    /**
	     * Creates the client with the given environment.
	     *
	     * @param {string} env - environment to point to, like 'prd'
	     * @param {string} developerKey - the developer key
	     * @param {function} globalRpcErrorCallback - callback to invoke on any cross-cutting RPC
	     * @param {bool} loggingEnabled - enable HTTP error logging if true
	     * call error. For example: SDK version mismatch
	     * @param {string} customSdkUrl - set to override the default sdk url
	     */
	    function HttpClient(env, developerKey, globalRpcErrorCallback, loggingEnabled, customSdkUrl) {
	        _classCallCheck(this, HttpClient);

	        if (!(_config2.default.urls[env] || customSdkUrl)) {
	            throw new Error('Invalid environment string. Please use one of: ' + JSON.stringify(_config2.default.urls));
	        }
	        this._instance = axios.create({
	            baseURL: customSdkUrl || _config2.default.urls[env]
	        });
	        if (loggingEnabled) {
	            _Util2.default.setUpHttpErrorLogging(this._instance);
	        }

	        var versionHeader = new _VersionHeader2.default();
	        var developerHeader = new _DeveloperHeader2.default(developerKey);
	        this._instance.interceptors.request.use(function (request) {
	            versionHeader.addVersionHeader(request);
	            developerHeader.addDeveloperHeader(request);
	            return request;
	        });

	        var errorHandler = new _ErrorHandler2.default(globalRpcErrorCallback);
	        this._instance.interceptors.response.use(null, function (error) {
	            throw errorHandler.handleError(error);
	        });
	    }

	    /**
	     * Creates a memberId.
	     *
	     * @param  {string} memberType - type of member to create. "PERSONAL" if undefined
	     * @return {Object} response - response to the API call
	     */


	    _createClass(HttpClient, [{
	        key: "createMemberId",
	        value: function createMemberId(memberType) {
	            if (memberType === undefined) {
	                memberType = "PERSONAL";
	            }
	            var req = {
	                memberType: memberType
	            };
	            var request = {
	                method: 'post',
	                url: '/members',
	                data: req
	            };
	            return this._instance(request);
	        }

	        /**
	         * Gets a member given an alias and a realm.
	         *
	         * @param {Object} alias - alias to lookup
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "resolveAlias",
	        value: function resolveAlias(alias) {
	            var realm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	            var request = {
	                method: 'get',
	                url: "/resolve-alias?value=" + alias.value + "&type=" + alias.type + "&realm=" + realm
	            };
	            return this._instance(request);
	        }

	        /**
	         * Gets the member's information.
	         *
	         * @param {string} memberId - member id to lookup the member for
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getMember",
	        value: function getMember(memberId) {
	            var request = {
	                method: 'get',
	                url: "/members/" + memberId
	            };
	            return this._instance(request);
	        }

	        /**
	         * Notifies a user.
	         *
	         * @param {Object} alias - user to notify
	         * @param {Object} body - body of the notification
	         * @param {string} realm - (optional) realm of the alias
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "notify",
	        value: function notify(alias, body, realm) {
	            var req = {
	                alias: alias,
	                body: body,
	                realm: realm
	            };
	            var request = {
	                method: 'post',
	                url: "/notify",
	                data: req
	            };
	            return this._instance(request);
	        }

	        /**
	         * Approve a first key for a member (self signed).
	         *
	         * @param {string} memberId - id of the member
	         * @param {Object} key - key to approve
	         * @param {Object} cryptoEngine - engine to use for signing
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "approveFirstKey",
	        value: function approveFirstKey(memberId, key, cryptoEngine) {
	            var signer, update, req, request;
	            return regeneratorRuntime.async(function approveFirstKey$(_context) {
	                while (1) {
	                    switch (_context.prev = _context.next) {
	                        case 0:
	                            _context.next = 2;
	                            return regeneratorRuntime.awrap(cryptoEngine.createSigner(_config2.default.KeyLevel.PRIVILEGED));

	                        case 2:
	                            signer = _context.sent;
	                            update = {
	                                memberId: memberId,
	                                operations: [{
	                                    addKey: {
	                                        key: _extends({
	                                            id: key.id,
	                                            publicKey: _Crypto2.default.strKey(key.publicKey),
	                                            level: key.level,
	                                            algorithm: key.algorithm
	                                        }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs })
	                                    }
	                                }]
	                            };
	                            _context.t0 = update;
	                            _context.t1 = memberId;
	                            _context.t2 = signer.getKeyId();
	                            _context.next = 9;
	                            return regeneratorRuntime.awrap(signer.signJson(update));

	                        case 9:
	                            _context.t3 = _context.sent;
	                            _context.t4 = {
	                                memberId: _context.t1,
	                                keyId: _context.t2,
	                                signature: _context.t3
	                            };
	                            req = {
	                                update: _context.t0,
	                                updateSignature: _context.t4
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/members/" + memberId + "/updates",
	                                data: req
	                            };
	                            return _context.abrupt("return", this._instance(request));

	                        case 14:
	                        case "end":
	                            return _context.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Approve the first keys for a member (self signed).
	         *
	         * @param {string} memberId - id of the member
	         * @param {Array} keys - keys to approve
	         * @param {Object} cryptoEngine - engine to use for signing
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "approveFirstKeys",
	        value: function approveFirstKeys(memberId, keys, cryptoEngine) {
	            var signer, update, req, request;
	            return regeneratorRuntime.async(function approveFirstKeys$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            _context2.next = 2;
	                            return regeneratorRuntime.awrap(cryptoEngine.createSigner(_config2.default.KeyLevel.PRIVILEGED));

	                        case 2:
	                            signer = _context2.sent;
	                            update = {
	                                memberId: memberId,
	                                operations: keys.map(function (key) {
	                                    return {
	                                        addKey: {
	                                            key: _extends({
	                                                id: key.id,
	                                                publicKey: _Crypto2.default.strKey(key.publicKey),
	                                                level: key.level,
	                                                algorithm: key.algorithm
	                                            }, key.expiresAtMs && { expiresAtMs: key.expiresAtMs })
	                                        }
	                                    };
	                                })
	                            };
	                            _context2.t0 = update;
	                            _context2.t1 = memberId;
	                            _context2.t2 = signer.getKeyId();
	                            _context2.next = 9;
	                            return regeneratorRuntime.awrap(signer.signJson(update));

	                        case 9:
	                            _context2.t3 = _context2.sent;
	                            _context2.t4 = {
	                                memberId: _context2.t1,
	                                keyId: _context2.t2,
	                                signature: _context2.t3
	                            };
	                            req = {
	                                update: _context2.t0,
	                                updateSignature: _context2.t4
	                            };
	                            request = {
	                                method: 'post',
	                                url: "/members/" + memberId + "/updates",
	                                data: req
	                            };
	                            return _context2.abrupt("return", this._instance(request));

	                        case 14:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Sends a notification to a user to request a payment.
	         *
	         * @param {Object} tokenPayload - requested transfer token
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "notifyPaymentRequest",
	        value: function notifyPaymentRequest(tokenPayload) {
	            var req = {
	                tokenPayload: tokenPayload
	            };
	            var request = {
	                method: 'post',
	                url: "/request-transfer",
	                data: req
	            };
	            return this._instance(request);
	        }

	        /**
	         * Notifies subscribed devices that a token payload should be endorsed and keys should be
	         * added.
	         *
	         * @param {Object} endorseAndAddKey - the endorseAndAddKey payload to be sent
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "notifyEndorseAndAddKey",
	        value: function notifyEndorseAndAddKey(endorseAndAddKey) {
	            var req = {
	                endorseAndAddKey: endorseAndAddKey
	            };
	            var request = {
	                method: 'post',
	                url: "/notify/endorse-and-add-key",
	                data: req
	            };
	            return this._instance(request);
	        }

	        /**
	         * Invalidate a notification.
	         *
	         * @param {Object} notificationId - the notification id to invalidate
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "invalidateNotification",
	        value: function invalidateNotification(notificationId) {
	            var req = {
	                notificationId: notificationId
	            };
	            var request = {
	                method: 'post',
	                url: "/notify/invalidate-notification",
	                data: req
	            };
	            return this._instance(request);
	        }

	        /**
	         * Gets banks.
	         *
	         * @param {Object} options - optional parameters for getBanks
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getBanks",
	        value: function getBanks() {
	            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	            var formattedOptions, ids, search, country, page, perPage, provider, url, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, id, request;

	            return regeneratorRuntime.async(function getBanks$(_context3) {
	                while (1) {
	                    switch (_context3.prev = _context3.next) {
	                        case 0:
	                            formattedOptions = Object.assign({}, {
	                                // Can be at most 1000
	                                ids: options.ids || [],
	                                search: options.search || '',
	                                country: options.country || '',
	                                // Default to 1 if not specified
	                                page: options.page,
	                                // Can be at most 200, default to 200 if not specified
	                                perPage: options.perPage,
	                                // Optional provider
	                                provider: options.provider || ''
	                            });
	                            ids = formattedOptions.ids, search = formattedOptions.search, country = formattedOptions.country, page = formattedOptions.page, perPage = formattedOptions.perPage, provider = formattedOptions.provider;
	                            url = "/banks?";
	                            _iteratorNormalCompletion = true;
	                            _didIteratorError = false;
	                            _iteratorError = undefined;
	                            _context3.prev = 6;

	                            for (_iterator = ids[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                                id = _step.value;

	                                url += "ids=" + encodeURIComponent(id) + "&";
	                            }
	                            _context3.next = 14;
	                            break;

	                        case 10:
	                            _context3.prev = 10;
	                            _context3.t0 = _context3["catch"](6);
	                            _didIteratorError = true;
	                            _iteratorError = _context3.t0;

	                        case 14:
	                            _context3.prev = 14;
	                            _context3.prev = 15;

	                            if (!_iteratorNormalCompletion && _iterator.return) {
	                                _iterator.return();
	                            }

	                        case 17:
	                            _context3.prev = 17;

	                            if (!_didIteratorError) {
	                                _context3.next = 20;
	                                break;
	                            }

	                            throw _iteratorError;

	                        case 20:
	                            return _context3.finish(17);

	                        case 21:
	                            return _context3.finish(14);

	                        case 22:
	                            if (search) url += "search=" + encodeURIComponent(search) + "&";
	                            if (country) url += "country=" + encodeURIComponent(country) + "&";
	                            if (page) url += "page=" + encodeURIComponent(page) + "&";
	                            if (perPage) url += "perPage=" + encodeURIComponent(perPage) + "&";
	                            if (provider) url += "provider=" + encodeURIComponent(provider) + "&";
	                            request = {
	                                method: 'get',
	                                url: url
	                            };
	                            return _context3.abrupt("return", this._instance(request));

	                        case 29:
	                        case "end":
	                            return _context3.stop();
	                    }
	                }
	            }, null, this, [[6, 10, 14, 22], [15,, 17, 21]]);
	        }

	        /**
	         * Retrieves a request for a token. Called by the web(user) or by a TPP, to get request details.
	         *
	         * @param {string} requestId - token request id
	         * @return {Promise} response - response to the API call
	         */

	    }, {
	        key: "retrieveTokenRequest",
	        value: function retrieveTokenRequest(requestId) {
	            var request;
	            return regeneratorRuntime.async(function retrieveTokenRequest$(_context4) {
	                while (1) {
	                    switch (_context4.prev = _context4.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/token-requests/" + requestId
	                            };
	                            return _context4.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context4.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Returns the Token member.
	         *
	         * @return {Promise} response - response to the API call
	         */

	    }, {
	        key: "getTokenMember",
	        value: function getTokenMember() {
	            var resolveAliasRes, tokenMemberId, getMemberRes;
	            return regeneratorRuntime.async(function getTokenMember$(_context5) {
	                while (1) {
	                    switch (_context5.prev = _context5.next) {
	                        case 0:
	                            _context5.next = 2;
	                            return regeneratorRuntime.awrap(this.resolveAlias(_Util2.default.tokenAlias(), _Util2.default.tokenRealm()));

	                        case 2:
	                            resolveAliasRes = _context5.sent;
	                            tokenMemberId = resolveAliasRes.data.member.id;
	                            _context5.next = 6;
	                            return regeneratorRuntime.awrap(this.getMember(tokenMemberId));

	                        case 6:
	                            getMemberRes = _context5.sent;
	                            return _context5.abrupt("return", getMemberRes.data.member);

	                        case 8:
	                        case "end":
	                            return _context5.stop();
	                    }
	                }
	            }, null, this);
	        }

	        /**
	         * Get a token ID based on its token request ID.
	         *
	         * @param {string} tokenRequestId - token request id
	         * @return {Object} response - response to the API call
	         */

	    }, {
	        key: "getTokenId",
	        value: function getTokenId(tokenRequestId) {
	            var request;
	            return regeneratorRuntime.async(function getTokenId$(_context6) {
	                while (1) {
	                    switch (_context6.prev = _context6.next) {
	                        case 0:
	                            request = {
	                                method: 'get',
	                                url: "/token-requests/" + tokenRequestId + "/token_id"
	                            };
	                            return _context6.abrupt("return", this._instance(request));

	                        case 2:
	                        case "end":
	                            return _context6.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return HttpClient;
	}();

	exports.default = HttpClient;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TransferTokenBuilder = function () {

	    /**
	     * Represents a Builder for a transfer token.
	     *
	     * @constructor
	     * @param {Object} client - The http client to use for the API call
	     * @param {Object} member - member performing the request
	     * @param {number} lifetimeAmount - the lifetime amount of the token
	     * @param {string} currency - currency of the token
	     */
	    function TransferTokenBuilder(client, member, lifetimeAmount, currency) {
	        _classCallCheck(this, TransferTokenBuilder);

	        this._client = client;
	        this._member = member;
	        this._blobPayloads = [];
	        this._tokenRequestId = "";

	        if (_Util2.default.countDecimals(lifetimeAmount) > _config2.default.decimalPrecision) {
	            throw new Error('Number of decimals in lifetimeAmount should be at most ' + _config2.default.decimalPrecision);
	        }

	        this._payload = {
	            version: _config2.default.transferTokenVersion,
	            refId: _Util2.default.generateNonce(),
	            transfer: {
	                currency: currency,
	                lifetimeAmount: lifetimeAmount.toString(),
	                instructions: {
	                    destinations: [],
	                    metadata: {}
	                },
	                redeemer: {},
	                attachments: []
	            }
	        };
	    }

	    /**
	     * Sets the fromId of the token
	     *
	     * @param {string} memberId - from memberId
	     * @return {TransferTokenBuilder} builder - returns back the builder object
	     */


	    _createClass(TransferTokenBuilder, [{
	        key: "setFromId",
	        value: function setFromId(memberId) {
	            if (!this._payload.from) {
	                this._payload.from = {};
	            }
	            this._payload.from.id = memberId;
	            return this;
	        }

	        /**
	         * Sets the source accountId of the token.
	         *
	         * @param {string} accountId - source accountId
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setAccountId",
	        value: function setAccountId(accountId) {
	            this._payload.transfer.instructions.source = {
	                account: {
	                    token: {
	                        memberId: this._member.memberId(),
	                        accountId: accountId
	                    }
	                }
	            };
	            return this;
	        }

	        /**
	         * Sets the source custom authorization.
	         *
	         * @param {string} bankId - source bank id
	         * @param {string} authorization - source custom authorization
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setCustomAuthorization",
	        value: function setCustomAuthorization(bankId, authorization) {
	            this._payload.transfer.instructions.source = {
	                account: {
	                    custom: {
	                        bankId: bankId,
	                        payload: authorization
	                    }
	                }
	            };
	            return this;
	        }

	        /**
	         * Sets the source bank authorization.
	         *
	         * @param {Object} authorization - bank authorization for source account
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setBankAuthorization",
	        value: function setBankAuthorization(authorization) {
	            this._payload.transfer.instructions.source = {
	                account: {
	                    tokenAuthorization: {
	                        authorization: authorization
	                    }
	                }
	            };
	            return this;
	        }

	        /**
	         * Sets the expiration date of the token.
	         *
	         * @param {number} expiresAtMs - expiration date in milliseconds
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setExpiresAtMs",
	        value: function setExpiresAtMs(expiresAtMs) {
	            this._payload.expiresAtMs = expiresAtMs;
	            return this;
	        }

	        /**
	         * Sets the endorse token timeout.
	         *
	         * @param {number} endorseUntilMs - time at which no more endorsements can be made
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setEndorseUntilMs",
	        value: function setEndorseUntilMs(endorseUntilMs) {
	            this._payload.endorseUntilMs = endorseUntilMs;
	            return this;
	        }

	        /**
	         * Sets the effective date of the token.
	         *
	         * @param {number} effectiveAtMs - effective date in milliseconds
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setEffectiveAtMs",
	        value: function setEffectiveAtMs(effectiveAtMs) {
	            this._payload.effectiveAtMs = effectiveAtMs;
	            return this;
	        }

	        /**
	         * Sets the maximum charge amount of the token.
	         *
	         * @param {number} chargeAmount - maximum charge amount.
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setChargeAmount",
	        value: function setChargeAmount(chargeAmount) {
	            if (_Util2.default.countDecimals(chargeAmount) > _config2.default.decimalPrecision) {
	                throw new Error('Number of decimals in amount should be at most ' + _config2.default.decimalPrecision);
	            }
	            this._payload.transfer.amount = chargeAmount;
	            return this;
	        }

	        /**
	         * Sets the description of the token.
	         *
	         * @param {string} description - description
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setDescription",
	        value: function setDescription(description) {
	            this._payload.description = description;
	            return this;
	        }

	        /**
	         * Add a transfer destination to the token.
	         *
	         * @param {object} endpoint - transfer endpoint
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "addDestination",
	        value: function addDestination(endpoint) {
	            this._payload.transfer.instructions.destinations.push(endpoint);
	            return this;
	        }

	        /**
	         * Sets the alias of the redeemer.
	         *
	         * @param {Object} redeemerAlias - alias of the redeemer
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setRedeemerAlias",
	        value: function setRedeemerAlias(redeemerAlias) {
	            this._payload.transfer.redeemer.alias = redeemerAlias;
	            return this;
	        }

	        /**
	         * Sets the realm of the redeemer.
	         *
	         * @param {string} redeemerRealm - realm of the redeemer
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setRedeemerRealm",
	        value: function setRedeemerRealm(redeemerRealm) {
	            this._payload.transfer.redeemer.realm = redeemerRealm;
	            return this;
	        }

	        /**
	         * Sets the memberId of the redeemer.
	         *
	         * @param {Object} redeemerMemberId - memberId of the redeemer
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setRedeemerMemberId",
	        value: function setRedeemerMemberId(redeemerMemberId) {
	            this._payload.transfer.redeemer.id = redeemerMemberId;
	            return this;
	        }

	        /**
	         * Sets the alias of the payee.
	         *
	         * @param {Object} toAlias - alias of the payee
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setToAlias",
	        value: function setToAlias(toAlias) {
	            if (!this._payload.to) {
	                this._payload.to = {};
	            }
	            this._payload.to.alias = toAlias;
	            return this;
	        }

	        /**
	         * Sets the realm of the payee.
	         *
	         * @param {string} toRealm - realm of the payee
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setToRealm",
	        value: function setToRealm(toRealm) {
	            if (!this._payload.to) {
	                this._payload.to = {};
	            }
	            this._payload.to.realm = toRealm;
	            return this;
	        }

	        /**
	         * Sets the memberId of the payee.
	         *
	         * @param {string} toMemberId - memberId of the payee
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setToMemberId",
	        value: function setToMemberId(toMemberId) {
	            if (!this._payload.to) {
	                this._payload.to = {};
	            }
	            this._payload.to.id = toMemberId;
	            return this;
	        }

	        /**
	         * Adds an attachment to the token.
	         *
	         * @param {Object} attachment - attachment (metadata).
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "addAttachment",
	        value: function addAttachment(attachment) {
	            this._payload.transfer.attachments.push(attachment);
	            return this;
	        }

	        /**
	         * Adds an attachment to the token, with the data.
	         *
	         * @param {string} ownerId - memberId of the owner of the file
	         * @param {string} type - MIME type of the file
	         * @param {string} name - name of the file
	         * @param {Buffer} data - byte array of the data of the file
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "addAttachmentData",
	        value: function addAttachmentData(ownerId, type, name, data) {
	            this._blobPayloads.push({
	                ownerId: ownerId,
	                type: type,
	                name: name,
	                data: data
	            });
	            return this;
	        }

	        /**
	         * Sets the pricing (fees/fx) of the token.
	         *
	         * @param {Object} pricing - pricing of the token
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setPricing",
	        value: function setPricing(pricing) {
	            this._payload.transfer.pricing = pricing;
	            return this;
	        }

	        /**
	         * Sets the purpose of payment of the token.
	         *
	         * @param {string} purposeOfPayment - purpose of payment
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setPurposeOfPayment",
	        value: function setPurposeOfPayment(purposeOfPayment) {
	            this._payload.transfer.instructions.metadata.transferPurpose = purposeOfPayment;
	            return this;
	        }

	        /**
	         * Sets the refId on the token.
	         *
	         * @param {string} refId - client generated reference id, at most 18 characters long.
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setRefId",
	        value: function setRefId(refId) {
	            if (refId.length > 18) {
	                throw new Error('The length of the refId is at most 18, got: ' + refId.length);
	            }
	            this._payload.refId = refId;
	            return this;
	        }

	        /**
	         * Sets acting as on the token.
	         *
	         * @param {Object} actingAs - entity the redeemer is acting on behalf of
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setActingAs",
	        value: function setActingAs(actingAs) {
	            this._payload.actingAs = actingAs;
	            return this;
	        }

	        /**
	         * Sets the token request ID.
	         *
	         * @param {string} tokenRequestId - token request id
	         * @return {TransferTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setTokenRequestId",
	        value: function setTokenRequestId(tokenRequestId) {
	            this._tokenRequestId = tokenRequestId;
	            return this;
	        }

	        /**
	         *  Sets the flag indicating whether a receipt is requested.
	         *
	         * @param {boolean} receiptRequested receipt requested flag
	         * @return {TransferTokenBuilder} builder
	         */

	    }, {
	        key: "setReceiptRequested",
	        value: function setReceiptRequested(receiptRequested) {
	            this._payload.receiptRequested = receiptRequested;
	            return this;
	        }

	        /**
	         * Builds the token payload.
	         *
	         * @return {Object} tokenPayload - token payload
	         */

	    }, {
	        key: "build",
	        value: function build() {
	            return this._payload;
	        }

	        /**
	         * Executes the createToken API call to the server, and returns a promise with the token.
	         *
	         * @return {Promise} token - the created and filled transfer token
	         */

	    }, {
	        key: "execute",
	        value: function execute() {
	            var _this = this;

	            return regeneratorRuntime.async(function execute$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            return _context2.abrupt("return", _Util2.default.callAsync(this.execute, function _callee() {
	                                var i, payload, attachment, res, error;
	                                return regeneratorRuntime.async(function _callee$(_context) {
	                                    while (1) {
	                                        switch (_context.prev = _context.next) {
	                                            case 0:
	                                                if (!(!_this._payload.transfer.instructions.source || !_this._payload.transfer.instructions.source.account.token && !_this._payload.transfer.instructions.source.account.tokenAuthorization && !_this._payload.transfer.instructions.source.account.bank && !_this._payload.transfer.instructions.source.account.custom)) {
	                                                    _context.next = 2;
	                                                    break;
	                                                }

	                                                throw new Error('No source on token');

	                                            case 2:
	                                                if (!(!_this._payload.transfer.redeemer.alias && !_this._payload.transfer.redeemer.id)) {
	                                                    _context.next = 4;
	                                                    break;
	                                                }

	                                                throw new Error('No redeemer on token');

	                                            case 4:
	                                                i = 0;

	                                            case 5:
	                                                if (!(i < _this._blobPayloads.length)) {
	                                                    _context.next = 14;
	                                                    break;
	                                                }

	                                                payload = _this._blobPayloads[i];
	                                                _context.next = 9;
	                                                return regeneratorRuntime.awrap(_this._member.createBlob(payload.ownerId, payload.type, payload.name, payload.data));

	                                            case 9:
	                                                attachment = _context.sent;

	                                                _this.addAttachment(attachment);

	                                            case 11:
	                                                i++;
	                                                _context.next = 5;
	                                                break;

	                                            case 14:
	                                                _context.next = 16;
	                                                return regeneratorRuntime.awrap(_this._client.createTransferToken(_this._payload, _this._tokenRequestId));

	                                            case 16:
	                                                res = _context.sent;

	                                                if (!(res.data.status === "FAILURE_EXTERNAL_AUTHORIZATION_REQUIRED")) {
	                                                    _context.next = 21;
	                                                    break;
	                                                }

	                                                error = new Error("FAILURE_EXTERNAL_AUTHORIZATION_REQUIRED");

	                                                error.authorizationDetails = res.data.authorizationDetails;
	                                                throw error;

	                                            case 21:
	                                                if (!(res.data.status !== "SUCCESS")) {
	                                                    _context.next = 23;
	                                                    break;
	                                                }

	                                                throw new Error(res.data.status);

	                                            case 23:
	                                                return _context.abrupt("return", res.data.token);

	                                            case 24:
	                                            case "end":
	                                                return _context.stop();
	                                        }
	                                    }
	                                }, null, _this);
	                            }));

	                        case 1:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return TransferTokenBuilder;
	}();

	exports.default = TransferTokenBuilder;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Util = __webpack_require__(7);

	var _Util2 = _interopRequireDefault(_Util);

	var _config = __webpack_require__(30);

	var _config2 = _interopRequireDefault(_config);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AccessTokenBuilder = function () {
	    /**
	     * Represents a Builder for a transfer token.
	     *
	     * @constructor
	     * @param {Object} client - The http client to use for the API call
	     * @param {Object} member - member performing the request
	     * @param {Array} resources - the resources to give access to
	     */
	    function AccessTokenBuilder(client, member, resources) {
	        _classCallCheck(this, AccessTokenBuilder);

	        this._client = client;
	        this._member = member;
	        this._tokenRequestId = "";

	        this._payload = {
	            version: _config2.default.accessTokenVersion,
	            refId: _Util2.default.generateNonce(),
	            access: {
	                resources: resources
	            }
	        };
	    }

	    /**
	    * Adds a from id.
	    *
	    * @param {String} memberId - fromId
	    * @return {AccessTokenBuilder} builder - returns back the builder object
	    */


	    _createClass(AccessTokenBuilder, [{
	        key: "setFromId",
	        value: function setFromId(memberId) {
	            if (!this._payload.from) {
	                this._payload.from = {};
	            }
	            this._payload.from.id = memberId;
	            return this;
	        }

	        /**
	         * Adds a resource for all addresses.
	         *
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllAddresses",
	        value: function forAllAddresses() {
	            this._payload.access.resources.push({
	                allAddresses: {}
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for one adress.
	         * @param {String} addressId - id of the address
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAddress",
	        value: function forAddress(addressId) {
	            this._payload.access.resources.push({
	                address: {
	                    addressId: addressId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for metadata of all accounts.
	         *
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllAccounts",
	        value: function forAllAccounts() {
	            this._payload.access.resources.push({
	                allAccounts: {}
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for metadata of all accounts at a given bank.
	         *
	         * @param {String} bankId - id of the bank
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllAccountsAtBank",
	        value: function forAllAccountsAtBank(bankId) {
	            this._payload.access.resources.push({
	                allAccountsAtBank: {
	                    bankId: bankId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for metadata of one account.
	         *
	         * @param {String} accountId - id of the account
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAccount",
	        value: function forAccount(accountId) {
	            this._payload.access.resources.push({
	                account: {
	                    accountId: accountId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for transactions of all accounts.
	         *
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllTransactions",
	        value: function forAllTransactions() {
	            this._payload.access.resources.push({
	                allTransactions: {}
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for transactions of all accounts at a given bank.
	         *
	         * @param {String} bankId - id of the bank
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllTransactionsAtbank",
	        value: function forAllTransactionsAtbank(bankId) {
	            this._payload.access.resources.push({
	                allTransactionsAtBank: {
	                    bankId: bankId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for transactions of one account.
	         *
	         * @param {String} accountId - id of the account
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAccountTransactions",
	        value: function forAccountTransactions(accountId) {
	            this._payload.access.resources.push({
	                transactions: {
	                    accountId: accountId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for balances of all accounts.
	         *
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllBalances",
	        value: function forAllBalances() {
	            this._payload.access.resources.push({
	                allBalances: {}
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for balances of all accounts at a given bank.
	         *
	         * @param {String} bankId - id of the bank
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAllBalancesAtBank",
	        value: function forAllBalancesAtBank(bankId) {
	            this._payload.access.resources.push({
	                allBalancesAtBank: {
	                    bankId: bankId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for balance of one account.
	         *
	         * @param {String} accountId - id of the account
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAccountBalances",
	        value: function forAccountBalances(accountId) {
	            this._payload.access.resources.push({
	                balance: {
	                    accountId: accountId
	                }
	            });
	            return this;
	        }

	        /**
	         * Adds a resource for full access.
	         *
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "forAll",
	        value: function forAll() {
	            return this.forAllAccounts().forAllAddresses().forAllTransactions().forAllBalances();
	        }

	        /**
	         * Sets the expiration date of the token.
	         *
	         * @param {number} expiresAtMs - expiration date in milliseconds
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setExpiresAtMs",
	        value: function setExpiresAtMs(expiresAtMs) {
	            this._payload.expiresAtMs = expiresAtMs;
	            return this;
	        }

	        /**
	         * Sets the endorse token timeout.
	         *
	         * @param {number} endorseUntilMs - time at which no more endorsements can be made
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setEndorseUntilMs",
	        value: function setEndorseUntilMs(endorseUntilMs) {
	            this._payload.endorseUntilMs = endorseUntilMs;
	            return this;
	        }

	        /**
	         * Sets the effective date of the token.
	         *
	         * @param {number} effectiveAtMs - effective date in milliseconds
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setEffectiveAtMs",
	        value: function setEffectiveAtMs(effectiveAtMs) {
	            this._payload.effectiveAtMs = effectiveAtMs;
	            return this;
	        }

	        /**
	         * Sets the description of the token.
	         *
	         * @param {string} description - description
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setDescription",
	        value: function setDescription(description) {
	            this._payload.description = description;
	            return this;
	        }

	        /**
	         * Sets the alias of the grantee.
	         *
	         * @param {Object} toAlias - alias of the grantee
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setToAlias",
	        value: function setToAlias(toAlias) {
	            if (!this._payload.to) {
	                this._payload.to = {};
	            }
	            this._payload.to.alias = toAlias;
	            return this;
	        }

	        /**
	         * Sets the memberId of the grantee.
	         *
	         * @param {string} toMemberId - memberId of the grantee
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setToMemberId",
	        value: function setToMemberId(toMemberId) {
	            if (!this._payload.to) {
	                this._payload.to = {};
	            }
	            this._payload.to.id = toMemberId;
	            return this;
	        }

	        /**
	         * Sets the realm of the grantee.
	         *
	         * @param {string} realm - realm of the grantee
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setToRealm",
	        value: function setToRealm(realm) {
	            if (!this._payload.to) {
	                this._payload.to = {};
	            }
	            this._payload.to.realm = realm;
	            return this;
	        }

	        /**
	         * Sets the refId on the token.
	         *
	         * @param {string} refId - client generated reference id
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setRefId",
	        value: function setRefId(refId) {
	            this._payload.refId = refId;
	            return this;
	        }

	        /**
	         * Sets acting as on the token.
	         *
	         * @param {Object} actingAs - entity the redeemer is acting on behalf of
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setActingAs",
	        value: function setActingAs(actingAs) {
	            this._payload.actingAs = actingAs;
	            return this;
	        }

	        /**
	         * Sets the token request ID.
	         *
	         * @param {string} tokenRequestId - token request id
	         * @return {AccessTokenBuilder} builder - returns back the builder object
	         */

	    }, {
	        key: "setTokenRequestId",
	        value: function setTokenRequestId(tokenRequestId) {
	            this._tokenRequestId = tokenRequestId;
	            return this;
	        }

	        /**
	         * Builds the token payload.
	         *
	         * @return {Object} tokenPayload - token payload
	         */

	    }, {
	        key: "build",
	        value: function build() {
	            return this._payload;
	        }

	        /**
	         * Executes the createToken API call to the server, and returns a promise with the token.
	         *
	         * @return {Promise} token - the created and filled access token
	         */

	    }, {
	        key: "execute",
	        value: function execute() {
	            var _this = this;

	            return regeneratorRuntime.async(function execute$(_context2) {
	                while (1) {
	                    switch (_context2.prev = _context2.next) {
	                        case 0:
	                            return _context2.abrupt("return", _Util2.default.callAsync(this.execute, function _callee() {
	                                var res, error;
	                                return regeneratorRuntime.async(function _callee$(_context) {
	                                    while (1) {
	                                        switch (_context.prev = _context.next) {
	                                            case 0:
	                                                if (!(_this._payload.access.resources.length < 1)) {
	                                                    _context.next = 2;
	                                                    break;
	                                                }

	                                                throw new Error('Must have at least one resource');

	                                            case 2:
	                                                if (!(!_this._payload.to || !_this._payload.to.alias && !_this._payload.to.id)) {
	                                                    _context.next = 4;
	                                                    break;
	                                                }

	                                                throw new Error('No recipient on token');

	                                            case 4:
	                                                _context.next = 6;
	                                                return regeneratorRuntime.awrap(_this._client.createAccessToken(_this._payload, _this._tokenRequestId));

	                                            case 6:
	                                                res = _context.sent;

	                                                if (!(res.data.status === "FAILURE_EXTERNAL_AUTHORIZATION_REQUIRED")) {
	                                                    _context.next = 11;
	                                                    break;
	                                                }

	                                                error = new Error("FAILURE_EXTERNAL_AUTHORIZATION_REQUIRED");

	                                                error.authorizationDetails = res.data.authorizationDetails;
	                                                throw error;

	                                            case 11:
	                                                return _context.abrupt("return", res.data.token);

	                                            case 12:
	                                            case "end":
	                                                return _context.stop();
	                                        }
	                                    }
	                                }, null, _this);
	                            }));

	                        case 1:
	                        case "end":
	                            return _context2.stop();
	                    }
	                }
	            }, null, this);
	        }
	    }]);

	    return AccessTokenBuilder;
	}();

	exports.default = AccessTokenBuilder;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TokenRequest = function () {
	    /**
	     * Constructs a TokenRequest.
	     *
	     * @param {Object} payload - token payload
	     */
	    function TokenRequest(payload) {
	        _classCallCheck(this, TokenRequest);

	        this.payload = payload;
	        this.options = {};
	    }

	    /**
	     * Creates a TokenRequest object
	     *
	     * @param {Object} payload - payload of the access or transfer token
	     * @return {TokenRequest} - TokenRequest object
	     */


	    _createClass(TokenRequest, [{
	        key: "setEmail",


	        /**
	         * Sets a default email for the TokenRequest
	         *
	         * @param {string} email - default email
	         * @return {TokenRequest} tokenRequest - token request
	         */
	        value: function setEmail(email) {
	            this.options.email = email;
	            return this;
	        }

	        /**
	         * Sets a default bank ID for the TokenRequest
	         *
	         * @param {string} bankId - bank ID
	         * @return {TokenRequest} tokenRequest - token request
	         */

	    }, {
	        key: "setBankId",
	        value: function setBankId(bankId) {
	            this.options.bankId = bankId;
	            return this;
	        }

	        /**
	         * Sets a redirect URL for the TokenRequest
	         *
	         * @param {string} redirectUrl - redirect URL
	         * @return {TokenRequest} tokenRequest - token request
	         */

	    }, {
	        key: "setRedirectUrl",
	        value: function setRedirectUrl(redirectUrl) {
	            this.options.redirectUrl = redirectUrl;
	            return this;
	        }
	    }], [{
	        key: "create",
	        value: function create(payload) {
	            return new TokenRequest(payload);
	        }
	    }]);

	    return TokenRequest;
	}();

	exports.default = TokenRequest;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	module.exports = require("es6-promise");

/***/ })
/******/ ])
});
;